프로젝트 관리(8)
개발 과정의 실무 이해

사전 질문(15분)
IT 제품이 개발되는 과정에서 디자인, 프론트엔드 개발, 백엔드 개발, 통합 및 연동 절차에 대해 어느정도 알고 있나요? 본인이 이해하고 있는 범위까지 적어봅니다.

PM은 이런 절차들에 대해 어디까지 알고 접근할 수 있어야 할까요? 그 기준을 어떻게 정하는 것이 좋을지 생각해 봅니다.

사전 질문 토론
✅ 1. IT 제품 개발 절차에 대해 PM은 어디까지 알고 있어야 할까요?
대부분 디자인 → 프론트엔드 → 백엔드 → 통합/연동/배포의 흐름을 개념적으로 이해하고 있었으며, 정확한 역할 구분과 상호작용 구조를 일부는 구체적으로, 일부는 개괄적으로 파악하고 있었습니다.
PM은 각 단계를 직접 구현할 수준까지는 아니어도, 협업을 원활히 이끌고 일정·리스크·우선순위 판단을 할 수 있을 정도로는 반드시 이해하고 있어야 한다는 공감대가 형성되었습니다.
특히 “개발자의 언어를 이해하고 질문할 수 있는 수준”, “문제가 발생했을 때 어느 영역에서 비롯된 것인지 감을 잡을 수 있는 수준”, “실행 결정과 조율이 가능한 정도”가 실질적인 기준으로 제시되었습니다.
✅ 2. PM이 절차별 지식을 갖추는 데 있어 기준은 무엇이어야 할까요?
모든 단계를 포괄하되 깊이는 다르게 접근해야 한다는 의견이 많았습니다.
예) 디자이너·개발자와 전문적 대화가 가능할 정도의 공통언어 확보
예) 기능 흐름, API 역할, 배포 프로세스 등은 맥락과 핵심 구조 정도까지
"개발자와의 협업에서 질문이 통하는 수준, 일정과 리소스를 판단할 수 있는 수준"이라는 답변이 가장 실무적으로 설득력 있게 반복되었습니다.
또한 PM의 관점에서는 전체 흐름을 통합적으로 조망하고, 연결 구조와 리스크 지점을 설계·관리하는 능력이 더욱 중요하다는 점이 강조되었습니다.

Case: 개발 과정에 대한 이해가 낮은 PM
리드로서 주니어 PM과 함께 제품팀을 이끌게 된 상황.  
기획 문서를 작성하는 과정에서, 기존 제품에 구현된 비즈니스 로직을 변경해야 하는 상황이 발생함.  
하지만 해당 로직의 변경은 디자인의 주요 컴포넌트 수정, DB 구조의 대대적인 개편, 화면 수 증가 등 연쇄적인 영향을 유발함.  
이러한 문제들을 고려하지 않은 채 기획 문서 작성이 계속 진행됨.  
이대로 기획이 확정될 경우, 개발이 사실상 불가능해질 것으로 판단됨.

PM이 개발 과정의 실무에 대해 이해하지 못하면
내가 의도한 제품과 실제 구현 간 괴리를 줄이기 위해 불필요한 커뮤니케이션 비용이 증가하게 된다.  
무엇이 간단하게 해결 가능한 일이고, 무엇이 구현 난이도가 높은 일인지에 대한 판단을 전적으로 디자이너나 개발자에게 맡길 수 없다.  
이들의 입장을 이해하고, 발생 가능한 개발 이슈에 유연하게 대응하려면, 실제 현장에서 벌어지는 개발 실무에 대해 어느 정도는 파악하고 있어야 한다.  
“PM은 제품팀의 개발 실무에 직접 참여할 일은 많지 않다.  하지만 개발 실무를 이해하지 못하면 제품팀을 관리할 수 없다.”

비즈니스 로직 변경은 단순한 기능 수정이 아니다.
하나의 로직을 바꾸는 결정은 UI/UX 구조, DB 설계, API 흐름, 테스트 구조 등 제품의 여러 부분에 영향
이 과정에서 설계·디자인·개발·QA까지 전 단계가 수정되기도
예: 회원 등급 정책 변경
기존: 구매 금액에 따라 자동 등급 부여
변경: 등급 조건 + 관리자 수동 승인 방식 추가
→ 필요한 작업 변화
[디자인] 등급 승인 화면/상태 추가
[프론트엔드] 승인 요청, 상태 표시, 필터 기능 추가
[백엔드] 등급 조건 처리 로직 수정, 승인 대기 DB 설계
[관리자 도구] 승인 기능 화면 추가
[테스트] 승인 요청 흐름에 대한 시나리오 추가

디자인 - 프론트엔드 - 백엔드 - 통합 및 연동

디자인 실무

디자인 실무 단계
PM-디자이너 킥오프 미팅: PRD 분석, 디자인 방향 및 우선순위 합의, 일정 수립
정보구조(IA), 사용자 흐름 설계: 화면 구조와 사용자 여정 시각화
와이어프레임 제작: 화면 레이아웃과 정보 배치의 기본 구조 설계
프로토타입 제작: 상호작용 요소가 포함된 작동하는 모형 제작
디자인 시안 제작: 최종 시각적 디자인 요소 적용
디자인 리뷰: 다양한 이해관계자의 피드백 수집 및 반영
디자인 핸드오프: 개발팀에 디자인 명세와 에셋 전달

1. PM-디자이너 킥오프 미팅
🧭 킥오프 미팅의 핵심 목표
제품의 비전과 목표를 디자이너와 공유하고 공통된 이해를 형성한다.
디자인 범위, 제약 조건, 구현 우선순위를 명확히 한다.
디자인 작업 일정과 검토 주기를 조율한다.
협업 중 피드백 방식과 소통 경로를 설정한다.
📌 킥오프 이후의 follow-up
회의 결과를 간단히 정리해 팀에 공유한다.
디자이너가 참고할 수 있는 자료(리서치, 벤치마크 등)를 전달한다.
주요 이해관계자와 정리된 방향성을 다시 확인한다.
디자인 탐색과 테스트를 위한 실행 계획을 세운다.(중간 점검, 사용자 테스트, 유연한 탐색 범위 포함)

1. PM-디자이너 킥오프 미팅
📌 PM이 디자인 협업을 위해 준비해야 할 자료
사용자 리서치와 시장 분석을 통해 도출한 인사이트
기존 제품의 사용 패턴 및 개선이 필요한 지점
브랜드 가이드라인, 기술적 제약, 디자인 관련 조건
기능 우선순위 및 단계적 구현 계획
💡 사례: K 결제 앱 리디자인 프로젝트
PM이 사전에 사용성 테스트 데이터를 준비→ “결제 과정이 3단계 이상일 경우 이탈률 40% 증가”라는 인사이트 도출
디자이너와 논의해 핵심 사용자 여정을 2단계로 축소하는 목표 설정
성과: 전환율 27% 개선, 사용자 만족도 조사 점수 상승

2. 정보구조(IA), 사용자 흐름 설계
IA와 사용자 흐름 리뷰 시 PM이 확인해야 할 사항  
비즈니스 목표에 부합하는지  
핵심 사용자 시나리오가 빠짐없이 반영되었는지  
탐색 흐름이 직관적인지  
예외 상황과 오류 케이스에 적절히 대응하는지  
향후 기능 확장을 유연하게 수용할 수 있는지  
다양한 디바이스 환경을 고려했는지  
기존 제품 구조와 일관성이 유지되는지

3. 와이어프레임 제작
와이어프레임 리뷰의 핵심 목표:  
사용자가 목표를 달성할 수 있는 구조인지 평가  
기능 요구사항이 빠짐없이 반영되었는지 확인  
정보의 우선순위와 시각적 계층 구조가 명확한지 검토  
효과적인 와이어프레임 피드백 방법:  
시각적 표현보다 기능적 목적에 집중  
사용자 입장에서 흐름과 맥락을 이해할 수 있는지 검토  
비즈니스 목표와의 연결성을 고려  
구체적인 예시를 들어 피드백 제시

4. 프로토타입 제작
프로토타입 평가의 핵심 질문:  
사용자는 인터페이스를 직관적으로 이해하고 조작할 수 있는가?  
핵심 목표까지의 흐름이 끊김 없이 이어지는가?  
오류나 예외 상황에서도 혼란 없이 다음 행동을 유도하는가?  
제품이 전달하고자 하는 가치가 경험을 통해 명확히 드러나는가?  
프로토타입 피드백 수집 방법:  
모더레이티드 사용성 테스트: 진행자가 사용자 행동을 관찰하고 질문  
게릴라 테스트: 빠르고 비공식적인 사용자 반응 확보  
피어 리뷰: 팀 내부 관점에서 기능성과 흐름 점검  
정량 지표 분석: 성공률, 완료 시간 등 수치 기반 평가

5. 디자인 시안 제작
디자인 시안에서 확인해야 할 핵심 요소
시각적 계층구조: 정보의 중요도에 따라 시선을 유도하는 구조  
색상 체계: 브랜드 일관성과 기능 구분, 접근성 고려  
타이포그래피: 가독성과 정보 구조, 브랜드 정체성 전달  
여백과 정렬: 균형 잡힌 배치와 정보 간 구분  
시각적 피드백: 사용자 행동에 대한 즉각적이고 명확한 반응  
다양한 상태별 디자인 확인:
빈 상태: 데이터가 없는 초기 화면  
로딩 상태: 데이터 로드 중임을 나타내는 표현  
오류 상태: 문제가 발생했을 때의 안내 방식  
성공 상태: 작업 완료 결과를 사용자에게 전달  

5. 디자인 시안 제작
시안 리뷰의 단계적 접근:
기능적 완전성: 요구된 내용을 모두 반영했는지 확인  
사용자 경험: 흐름이 자연스럽고 사용이 쉬운지  
브랜드 일관성: 디자인 시스템에 맞게 구현되었는지  
접근성: 다양한 사용자 환경을 고려했는지 
주관적 의견과 객관적 평가의 구분:
개인적 취향보다 사용자 중심의 판단 기준 유지  
감각적 인상보다 구체적인 근거와 원칙에 기반한 피드백 제공  
비즈니스 목표 달성에 기여하는 방향으로 평가

6. 디자인 리뷰
리뷰에 포함해야 할 이해관계자
제품팀: PM, 디자이너, 개발 리드
주제 전문가: 필요시 관련 분야 전문가
사용자 대표: 가능한 경우 실제 사용자 또는 UX 리서처
비즈니스 의사결정자: 전략적 방향성 확인
효과적인 디자인 피드백 제공법
구체적이고 실행 가능함
개인 취향이 아닌 원칙에 기반함
문제 지적과 함께 해결 방향 제시
디자이너의 전문성을 존중함

7. 디자인 핸드오프
핸드오프 미팅의 효과적 진행  
디자이너가 직접 디자인 내용을 설명하며 미팅을 시작  
개발자의 질문과 우려를 경청하고 필요 시 조율  
모호한 부분은 구체적으로 정의하고 결정사항을 명확히 기록  
기술적 제약을 고려해 구현 우선순위를 함께 조정  
핸드오프 이후 PM의 역할  
디자인과 개발 간 커뮤니케이션이 원활히 유지되도록 조율  
구현 중 발생하는 디자인 변경 사항을 관리  
진행 상황에 따라 디자인 피드백을 유연하게 전달  
최종 결과물이 디자인 의도와 일관되도록 끝까지 확인

프론트엔드 개발 실무

프론트엔드 개발 단계
프론트엔드 개발 환경 구성: 개발 도구 및 라이브러리 설정
UI 컴포넌트 구현: 기본 UI 요소 및 재사용 가능한 컴포넌트 개발
레이아웃 구성: 디자인에 따른 화면 구조 구현
반응형 구현: 다양한 화면 크기 대응 처리
상호작용 추가: 사용자 입력 처리 및 애니메이션 구현
API 연동: 백엔드와 데이터 통신 기능 구현
프론트엔드 테스트: 컴포넌트 및 통합 테스트 수행

1. 프론트엔드 개발 환경 구성
프론트엔드 개발 환경 구성의 주요 요소  
기술 스택 선택: React, Vue, Angular 등 프로젝트에 적합한 프레임워크 결정  
빌드 도구: Webpack, Vite 등 코드 번들링과 최적화를 위한 도구  
패키지 관리자: npm, yarn을 활용한 외부 라이브러리 설치 및 관리  
코드 품질 도구: ESLint, Prettier 등 일관된 코드 스타일과 정적 분석 지원  
버전 관리: Git을 통한 협업 기반의 코드 변경 이력 관리  
기술 스택 선택이 미치는 영향  
개발 속도와 생산성  
유지보수의 난이도와 장기적인 안정성  
채용 시장에서의 개발자 접근성  
최종 사용자 경험과 성능에 미치는 영향  
향후 기능 확장과 지속 운영 가능성  

1. 프론트엔드 개발 환경 구성
PM이 고려해야 할 질문  
이 기술 스택이 현재 제품 요구사항에 적합한가?  
환경을 구성하는 데 필요한 시간과 인력은 어느 정도인가?  
선택한 기술이 이후 개발 속도와 유지보수에 어떤 영향을 줄 수 있는가?  
기술적 부채나 장기적 위험 요소는 무엇인가?


2. UI 컴포넌트 구현
컴포넌트 기반 개발의 핵심 원칙  
재사용성: 다양한 화면에서 일관된 방식으로 반복 활용 가능  
독립성: 다른 컴포넌트와 최소한의 결합으로 단독 동작 가능  
단일 책임: 하나의 역할에 집중해 명확한 목적을 가짐  
테스트 용이성: 각 컴포넌트를 개별적으로 검증할 수 있는 구조  
주요 UI 컴포넌트 유형  
기본 요소: 버튼, 입력 필드, 체크박스 등 사용자 인터랙션의 최소 단위  
복합 컴포넌트: 폼, 카드, 모달, 드롭다운 등 여러 요소의 조합  
레이아웃 컴포넌트: 그리드, 컨테이너, 플렉스 등 화면 구조를 잡는 구성  
페이지 템플릿: 특정 유형의 페이지에서 반복되는 기본 틀 

2. UI 컴포넌트 구현
컴포넌트 개발 과정에서 PM의 기여  
디자인 시스템과의 일관성 유지  
핵심 기능 위주의 컴포넌트부터 우선 개발하도록 조율  
재사용 가능성이 높은 구성 요소를 선별  
전체 프로젝트 일정과 연계해 개발 순서를 최적화  
컴포넌트 개발 과정에서 자주 발생하는 문제  
디자인과 구현 간 불일치로 인한 의도 차이  
처음엔 단순했지만 점점 복잡해지는 컴포넌트 범위  
범용성과 맞춤화의 균형이 어긋나는 설계  
렌더링 최적화 부족이나 무거운 의존성으로 인한 성능 저하

3. 레이아웃 구성
레이아웃 구현의 핵심 요소  
그리드 시스템: 정렬과 여백의 일관성을 위한 기본 틀  
컨테이너와 래퍼: 콘텐츠를 그룹화하고 적절한 여백을 제공  
정렬과 배치: 요소 간의 관계를 시각적으로 표현  
여백과 간격: 콘텐츠 간 간격을 일관되게 유지  
레이아웃 구현에 영향을 미치는 요소  
브라우저 및 기기 호환성: 다양한 환경에서 동일한 동작을 보장  
콘텐츠 가변성: 길이나 양이 다른 콘텐츠에도 유연하게 대응  
접근성 요구사항: 시각적 확대, 스크린리더 등 보조기술 대응  
성능 고려사항: 복잡한 레이아웃으로 인한 렌더링 부담 최소화

4. 반응형/적응형 구현
반응형 디자인(Responsive Design)  
하나의 웹사이트가 모든 디바이스에 유연하게 대응하도록 레이아웃을 조정  
CSS 미디어 쿼리를 활용해 화면 크기에 따라 자동으로 재배치  
적응형 디자인(Adaptive Design)  
디바이스 유형별로 고정된 레이아웃을 제공  
서버나 클라이언트에서 디바이스를 감지해 해당 레이아웃을 노출  
구현 전략의 주요 고려사항  
사용자 디바이스 분포와 사용 비중  
모바일과 데스크톱의 주요 사용 컨텍스트 차이  
디바이스 간 브랜드 경험의 일관성  
개발과 유지보수 측면의 효율성과 리소스 한계 

4. 반응형/적응형 구현
PM이 반응형/적응형 구현에 기여하는 부분  
지원할 디바이스 우선순위를 데이터 기반으로 결정  
디바이스별 핵심 사용자 흐름을 정의  
기능 차별화가 필요한 경우 디바이스 특성에 맞게 조정  
다양한 환경을 고려한 테스트 전략 수립  
구현 과정에서 자주 발생하는 문제  
모바일 사용자 경험이 뒷전으로 밀리는 데스크톱 중심 사고  
작은 화면에 맞지 않는 과도한 콘텐츠 배치  
기능 불일치로 인한 사용자 혼란  
소수 환경에 대한 테스트 부족 

4. 반응형/적응형 구현
사례:
H 여행 플랫폼의 검색 결과 페이지 개발 시
데이터 분석 결과 모바일:데스크톱 사용 비율 = 65:35
PM 주도로 "모바일 우선" 전략 채택, 좁은 화면에 최적화된 필터 UI 우선 개발
결과: 모바일 전환율 23% 향상, 개발 리소스 효율적 분배

5. 상호작용 추가
상호작용(인터랙션) 구현의 주요 영역  
사용자 입력 처리: 클릭, 터치, 드래그, 키보드 등 다양한 입력 수단 대응  
피드백 제공: 애니메이션, 색상 변화, 소리 등 사용자 반응에 대한 즉각적 표현  
상태 변화: 요소가 갖는 여러 상태 간의 전환 설계  
전환 효과: 페이지나 화면 간 이동 시의 애니메이션 처리  
상호작용 품질의 핵심 요소  
반응성: 입력에 대한 지연 없는 응답  
일관성: 유사한 맥락에서 동일하게 동작하는 구조  
자연스러움: 현실 세계와 유사한 움직임을 반영한 전환  
목적성: 사용자의 이해와 작업 완수를 돕는 기능적 흐름 

5. 상호작용 추가
상호작용 구현의 도전과제  
성능 영향: 부드러운 인터랙션을 위한 최적화 필요  
브라우저 호환성: 다양한 기기와 브라우저에서 동일한 동작 확보  
접근성: 모션에 민감한 사용자나 보조 기술 사용자를 고려한 설계  
과도한 효과: 의미 없는 화려함이 오히려 사용성 저해 요인이 될 수 있음  
PM의 기여 포인트  
핵심 인터랙션을 선별하고 우선순위를 설정  
상호작용이 전달하는 사용자 가치를 명확히 정의  
성능과 연출 사이의 균형을 팀과 함께 조율  
제품 전반에 걸쳐 일관된 상호작용 경험 유지  
사용성 테스트를 통해 실제 사용자 반응 기반의 검증 진행

6. API 연동
API 연동의 핵심 요소:
데이터 요청: 백엔드 서버에 필요 정보 요청
응답 처리: 받은 데이터 파싱 및 가공
오류 처리: 요청 실패, 타임아웃 등 대응
상태 관리: 로딩, 성공, 실패 상태 관리
캐싱: 반복 요청 최소화를 위한 데이터 저장
API 연동 아키텍처:
REST API: 리소스 중심의 HTTP 요청/응답
GraphQL: 필요한 데이터만 정확히 요청
WebSocket: 실시간 양방향 통신
서버 이벤트: 서버에서 클라이언트로 푸시 알림

6. API 연동
API 연동 관련 의사결정 영역:
실시간성 요구사항: 데이터 최신성 중요도
오프라인 지원: 네트워크 없을 때 동작 방식
데이터 일관성: 여러 화면에서 동일 데이터 처리
성능 요구사항: 응답 시간 및 렌더링 성능
API 연동에서 자주 발생하는 문제:
프론트엔드-백엔드 불일치: API 명세 차이
비동기 처리 복잡성: 여러 API 호출 의존성
에러 처리 미흡: 다양한 오류 상황 대응 부족
성능 이슈: 과도한 요청, 큰 데이터 처리 지연

7. 프론트엔드 테스트
프론트엔드 테스트 유형:
단위 테스트: 개별 함수/컴포넌트 기능 검증
통합 테스트: 여러 컴포넌트 상호작용 검증
E2E 테스트: 실제 사용자처럼 앱 전체 흐름 테스트
시각적 테스트: UI 외관 변화 감지
PM이 테스트 과정에서 고려할 사항:
테스트 범위와 깊이: 얼마나 철저히 테스트할지
자동화 수준: 수동 vs 자동화 테스트 균형
테스트 우선순위: 핵심 기능 집중 테스트
테스트 환경: 지원할 브라우저/기기 조합

Break Time

백엔드 개발 실무

백엔드 개발 단계
백엔드 개발 환경 구성: 서버, 데이터베이스 환경 설정
데이터베이스 설계: 정보 저장 구조 및 관계 정의
API 설계: 프론트엔드와 통신할 인터페이스 명세 작성
API 개발: 설계된 API 엔드포인트 구현
비즈니스 로직 구현: 핵심 기능 및 데이터 처리 로직 개발
인증/보안 구현: 사용자 인증 및 데이터 보안 처리
백엔드 테스트: 서버 로직 및 API 동작 검증
서버 인프라 구성: 배포 환경 및 서버 리소스 설정

1. 백엔드 개발 환경 구성
주요 기술 스택 구성요소  
프로그래밍 언어: Java, Python, Node.js, Go 등 시스템 요구사항에 맞는 언어 선택  
프레임워크: Spring, Django, Express, Laravel 등 언어별 주요 프레임워크 활용  
데이터베이스: MySQL, PostgreSQL, MongoDB, Redis 등 요구되는 구조와 성능에 따라 결정  
인프라: AWS, Google Cloud, Azure, 온프레미스 등 서비스 배포 및 운영 환경  
개발 도구: IDE, 버전 관리 도구(Git), CI/CD 파이프라인 등 협업과 자동화 지원 도구  
개발 환경 계층  
로컬 환경: 개발자 개인이 기능을 실험하고 구현하는 공간  
개발 환경: 팀 단위 개발을 위한 공유 환경 및 지속적 통합 대상  
스테이징 환경: 운영 전 최종 점검을 위한 실제 환경과 유사한 테스트 공간  
프로덕션 환경: 최종 사용자에게 제품이 제공되는 실서비스 환경


1. 백엔드 개발 환경 구성
PM이 기술 스택 논의에 기여할 수 있는 부분:
비즈니스 요구사항과 기술 선택이 어떻게 연결되는지 판단  
제품 로드맵을 반영해 기술의 확장성과 장기 운영 가능성 고려  
팀의 현재 기술 역량과 향후 채용 계획까지 포함해 현실적인 선택 유도  
기존 시스템과의 연동이나 이전 계획 등 통합 관점에서 조율  
자주 발생하는 기술 스택 관련 의사결정:
모놀리스 vs 마이크로서비스 아키텍처
관계형 DB vs NoSQL DB
서버리스 vs 서버 기반 구조
클라우드 서비스 vs 자체 호스팅

2. 데이터베이스 설계
데이터베이스 설계가 제품에 미치는 영향  
성능: 효율적인 쿼리 구조는 사용자 경험과 직접 연결됨  
확장성: 사용자 수나 데이터 양이 증가해도 안정적으로 대응할 수 있어야 함  
유지보수성: 구조 변경이 용이하고 예기치 않은 오류 발생 가능성이 낮아야 함  
데이터 무결성: 저장된 정보의 정확성과 일관성을 보장할 수 있어야 함  
PM이 데이터베이스 설계에 기여할 수 있는 부분  
핵심 비즈니스 데이터와 주요 엔티티 간 관계를 명확히 정의  
데이터 보존 기간, 개인정보 보호 등 정책 및 규제 사항을 설계에 반영  
기능 흐름에 따라 성능과 가용성의 우선순위를 기술 팀과 함께 조율  
제품 로드맵을 반영해 미래 확장을 고려한 구조 요구사항 제시

3. API 설계
PM이 API 설계 과정에서 고려할 요소  
프론트엔드에서 필요한 데이터와 흐름이 실제 API로 구현 가능한지 확인  
기존 시스템이나 외부 서비스와 연동 시 필요한 데이터 구조와 처리 방식 고려  
웹, 모바일, 제휴 파트너 등 다양한 클라이언트에서도 공통으로 사용할 수 있는지 검토  
앞으로 기능이 확장될 가능성을 고려해 구조가 유연한지 개발자와 논의  
API 설계 관련 의사결정 영역  
외부에 제공하는 API가 있다면 인증 방식과 접근 제한 설정 필요  
응답 속도, 호출 빈도 등 성능 기준을 설정하고 테스트 계획 수립  
요청 횟수 제한이나 파트너별 사용량 제한 같은 사용 제어 조건 설정  
에러 발생 시 사용자에게 어떤 메시지를 보여줄지, 재시도나 대체 흐름은 어떤 방식으로 처리할지 협의

3. API 설계
사례:
T 티켓팅 플랫폼의 API 설계 과정에서
PM이 향후 3년 로드맵 바탕으로 확장 요구사항 제시
"파트너사 연동"과 "화이트 라벨링" 기능을 고려한 API 버저닝 전략 제안
개발팀과 함께 API 설계 워크숍 진행하여 확장 가능한 구조 수립
결과: 1년 후 대형 파트너 연동 시 API 변경 없이 구현 가능

4. API 개발
API 개발 관련 일반적 이슈  
프론트엔드와 백엔드 간 계약된 데이터 구조나 응답 형식이 다르게 구현되는 경우  
응답 속도가 느려 사용자 경험에 영향을 주는 상황과 이를 개선하기 위한 성능 최적화 필요  
여러 사용자의 동시 요청으로 인해 발생하는 충돌이나 처리 순서 오류  
기존에 사용 중인 클라이언트가 새로운 API 변경에 따라 문제를 겪는 백워드 호환성 이슈  
PM의 API 개발 과정 기여 방법  
사용자 흐름에 따라 어떤 API가 더 중요한지 우선순위를 명확히 설정  
의존 관계나 구현 난이도를 고려해 기능 개발 순서를 개발자와 조율  
예외적인 상황이나 경계 케이스를 미리 정의해 누락 없는 개발 유도  
API 문서 작성과 테스트 과정에서 필요한 정보 제공 및 결과 확인

5. 비즈니스 로직 구현
비즈니스 로직이란  
제품이 제공하는 핵심 기능을 구성하는 규칙과 절차를 코드로 표현한 것  
데이터 처리, 계산, 조건 분기 등 실제 사용자의 행동에 따라 시스템이 작동하는 방식  
비즈니스 개념이나 도메인 지식이 소프트웨어 형태로 구현된 결과  
비즈니스 로직 구현 접근법  
계층형 아키텍처: 사용자 인터페이스, 로직, 데이터 계층을 분리해 구조화  
도메인 주도 설계(DDD): 실제 비즈니스 개념을 중심으로 설계하고 코드 구조 반영  
마이크로서비스: 주요 기능 단위를 분리해 독립적인 서비스로 관리  
이벤트 소싱: 상태 변경을 이벤트의 흐름으로 기록하고 처리 

5. 비즈니스 로직 구현
PM이 비즈니스 로직 구현에 기여하는 방식  
핵심 기능의 규칙과 제약조건을 구체적으로 정의  
엣지 케이스나 예외 상황을 개발 전에 명확히 문서화  
사용자 흐름이나 리스크를 고려해 구현 우선순위를 제시  
개발자와 논의할 수 있는 실제 사용 시나리오를 기반으로 검증 지원  
자주 발생하는 비즈니스 로직 관련 이슈  
요구사항을 해석하는 과정에서 개발자와 기획자 간 의미 차이 발생  
비즈니스 규칙이 바뀔 때 코드 구조까지 수정이 필요해 유지보수가 어려움  
예외 상황이나 경계값 처리 누락으로 인해 생기는 버그  
복잡한 계산 로직이나 조건 분기로 인해 성능 저하 발생

5. 비즈니스 로직 구현
사례:
G 인슈어테크 스타트업의 자동차 보험 견적 엔진 개발 시
PM이 보험 전문가와 개발팀 사이에서 복잡한 요율 규칙을 명확히 문서화
20개 이상의 변수와 조건별 가중치를 의사결정 테이블로 정리
엣지 케이스 5가지 시나리오 직접 작성하여 테스트 케이스 제공
결과: 견적 정확도 95% 이상 달성, 규제 준수 감사 원활히 통과

6. 인증/보안 구현
PM이 고려해야 할 보안 관련 의사결정  
사용자 인증 흐름: 가입, 로그인, 비밀번호 복구 등의 절차를 어떻게 설계할지  
권한 모델 정의: 역할별로 어떤 기능과 데이터에 접근할 수 있을지 설정  
개인정보 처리 방침: 수집, 저장, 활용 방식과 사용자 동의 절차 명확화  
규제 준수: GDPR, CCPA 등 관련 법적 요구사항을 제품 흐름에 반영  
자주 간과되는 보안 고려사항  
비밀번호 정책과 계정 잠금: 보안 강도를 유지하기 위한 기준과 절차  
세션 관리: 일정 시간 후 자동 로그아웃 등 만료 처리 방식  
데이터 보존 및 삭제: 사용자 요청 또는 정책에 따른 데이터 유지 기간 정의  
보안 감사와 모니터링: 이상 행동 감지, 접근 기록 추적 등 시스템 보호 체계

7. 백엔드 테스트
백엔드 테스트 유형  
단위 테스트: 개별 함수나 클래스가 정확히 작동하는지 검증  
통합 테스트: 여러 컴포넌트나 서비스가 서로 잘 연동되는지 확인  
API 테스트: 외부나 프론트엔드에서 호출하는 엔드포인트가 정확히 응답하는지 테스트  
부하 테스트: 많은 사용자가 동시에 접속해도 시스템이 안정적으로 작동하는지 측정  
보안 테스트: 취약점이나 위협 요소가 없는지 점검해 안전성을 확보  
PM이 백엔드 테스트에 기여하는 방식  
실제 사용 흐름에 기반한 핵심 시나리오를 개발자에게 제공  
비즈니스 중요도에 따라 어떤 기능부터 테스트할지 우선순위 설정을 지원  
사용자 수, 응답 속도 등 요구사항에 따라 성능 기준을 정의  
테스트 결과를 토대로 릴리스 여부를 판단하고 필요 시 우선 대응 영역 조정

8. 서버 인프라 구축
인프라 구축 접근법  
클라우드 네이티브: AWS, GCP 등 클라우드 서비스를 중심으로 구성해 유연성과 확장성 확보  
하이브리드: 온프레미스 시스템과 클라우드를 병행해 기존 자산과 새로운 인프라를 통합  
컨테이너화: Docker 등을 활용해 환경 일관성과 배포 효율성 확보  
인프라 as 코드(IaC): 인프라 설정을 코드로 관리하고 자동화  
인프라 관련 주요 고려사항  
초기 구축 비용과 장기 운영 비용 간의 균형  
서비스 대상 지역에 따른 인프라 분산과 지연 시간 최적화  
데이터 저장 위치, 접근 권한 등 규제 및 컴플라이언스 충족 여부  
배포 자동화, 이상 감지, 로그 수집 등 운영과 모니터링 체계 구축 수준

통합 및 연동 실무

통합 및 연동 단계
통합 환경 구성: 프론트엔드와 백엔드 연결 환경 설정
통합 테스트: 주요 기능 간 연결성과 성능을 사용자 흐름 기준으로 검증
오류 시나리오 테스트: 예외 상황 처리 검증
성능 최적화: 로딩 시간, 응답성 등 개선
통합 이슈 해결: 발견된 문제점 수정 및 재검증
최종 통합 승인: 통합 완료 확인 및 QA 단계 준비

1. 통합 환경 구성
통합 환경 구성의 핵심 요소  
통합 서버: 프론트엔드와 백엔드가 연결되어 작동하는 실제 통합 테스트용 서버  
테스트 데이터: 실제 서비스 상황과 유사한 데이터를 기반으로 한 시나리오 구성  
의존성 서비스: 외부 API나 인증 시스템 등 연동 대상 서비스 포함 여부 확인  
통합 계정: 관리자, 일반 사용자 등 다양한 권한 수준을 테스트할 수 있는 계정 구성  
모니터링 도구: 통합 중 오류 추적과 성능 상태를 확인할 수 있는 로깅 및 디버깅 도구  
일반적인 통합 환경 유형  
개발 통합 환경: 개발 중 컴포넌트 간 연동을 빠르게 확인하는 용도  
QA/테스트 환경: 기능별 테스트와 회귀 테스트가 이뤄지는 정식 검증 환경  
스테이징 환경: 프로덕션과 동일한 조건에서 배포 직전의 최종 점검을 수행  
프로덕션 미러: 실제 서비스 환경을 복제해 민감한 테스트나 안정성 점검을 진행

2. 통합 테스트
통합 테스트의 핵심 검증 항목  
API 연동: 명세와 구현이 일치하는지, 데이터 구조가 기대한 형태인지  
데이터 흐름: 입력 → 처리 → 저장 → 출력 과정이 정확하게 연결되는지  
상태 관리: 초기화, 전이, 지속성 등 앱의 상태 변화가 안정적으로 작동하는지  
성능: 응답 시간, 처리 속도, 동시 요청 처리 등 실사용에 문제가 없는지  
주요 테스트 시나리오  
폼 제출: 입력값이 서버에 전달되고 결과가 정확히 반영되는지  
CRUD 작업: 생성, 조회, 수정, 삭제가 데이터베이스에 정상 반영되는지  
실시간 동기화: 여러 컴포넌트나 탭에서 데이터 상태가 일관되게 유지되는지  
권한별 흐름: 사용자 권한에 따라 데이터 접근이 정확히 제한되는지 

2. 통합 테스트
자주 발생하는 통합 이슈  
API 명세와 실제 구현 간의 불일치  
예외 처리 미흡으로 오류 상황에서 흐름 중단  
비동기 처리 순서 꼬임, 캐시 불일치로 인한 잘못된 데이터 표시  
상태 초기화 누락, 과도한 전역 상태 공유, 메모리 누수  
응답 지연, 타임아웃 등 성능 저하 이슈  
PM이 기여할 수 있는 부분  
중요한 테스트 대상과 사용자 흐름을 정의해 우선순위를 설정  
예상 오류나 경계 케이스를 시나리오에 포함  
성능 기준 및 허용 범위 정의  
테스트 결과를 바탕으로 출시 가능성 판단 및 우선 대응 항목 조정

3. 오류 시나리오 테스트
오류 시나리오의 주요 유형  
사용자 입력 오류: 형식 오류, 필수 항목 누락 등 사용자 입력에 대한 검증 실패  
네트워크 오류: 연결 끊김, 타임아웃, 불완전 응답 등 네트워크 환경 문제  
서버 오류: 내부 서버 오류나 일시적 서비스 불가 상태  
권한 오류: 인증 실패나 접근 권한이 부족한 요청 처리  
데이터 불일치: 화면에 표시되는 값과 저장된 데이터 간의 불일치 발생  
오류 테스트 접근법  
예상 오류: 자주 발생하는 일반 오류 상황을 시뮬레이션하여 테스트  
경계 조건: 최대/최소값, 비정상적인 입력 등 극단적 상황을 테스트  
카오스 테스트: 장애를 인위적으로 주입해 시스템의 복원력 확인  
사용자 흐름 중단: 기능 수행 중 오류 발생 시 사용자 경험을 점검 

3. 오류 시나리오 테스트
PM이 오류 테스트에 기여할 수 있는 부분  
비즈니스에 영향을 주는 주요 오류 상황의 우선순위를 정리  
오류 발생 시 사용자에게 보여줄 흐름과 경험을 정의  
복구 가능하거나 대체 가능한 흐름을 설계해 실패 대응을 보완  
오류 메시지가 명확하고 사용자 친화적인지 검토  
오류 처리에서 자주 발생하는 문제  
모호한 오류 메시지: 사용자에게 기술 용어만 제공되어 이해 불가  
복구 경로 부재: 오류 발생 후 사용자가 무엇을 해야 할지 안내 없음  
불필요한 내부 정보 노출: 시스템 내부 구조나 디버깅 정보를 그대로 표시  
처리 방식 불일치: 동일한 오류임에도 상황에 따라 다른 대응으로 혼란 유발

4. 성능 최적화
성능 최적화의 핵심 영역  
로딩 시간: 초기 페이지 및 컴포넌트가 화면에 표시되기까지의 속도  
응답성: 클릭, 스크롤 등 사용자 인터랙션에 대한 반응 시간  
자원 활용: CPU, 메모리, 네트워크 사용량을 최소화해 효율 확보  
확장성: 데이터나 사용자 수 증가에 따라 성능이 유지되는 능력  
배터리 효율성: 모바일 환경에서 배터리 소모를 최소화  
주요 성능 최적화 접근법  
코드 최적화: 반복 연산 제거, 알고리즘 개선으로 처리 속도 향상  
렌더링 최적화: 불필요한 리렌더링 방지로 UI 응답성 개선  
네트워크 최적화: 요청 수를 줄이고 데이터 크기를 최소화  
캐싱 전략: 반복 요청 없이 이전 데이터를 재사용하도록 설계  
지연 로딩: 필요한 시점에만 리소스를 불러와 초기 로딩 최소화 

4. 성능 최적화
사례:
P 부동산 앱의 매물 검색 페이지 최적화 시
PM이 분석 도구로 평균 로딩 시간 5.2초 및 이탈률 상관관계 발견
"3초 이상 로딩 시 이탈률 40% 증가" 데이터로 개선 우선순위 정당화
개발팀과 협업하여 이미지 최적화, 지연 로딩 전략 수립
결과: 로딩 시간 67% 단축, 페이지 체류 시간 28% 증가, 전환율 개선

5. 통합 이슈 해결
통합 이슈의 주요 유형  
인터페이스 불일치: API 명세와 실제 구현 간 차이로 인한 연결 실패  
데이터 변환 문제: 형식 불일치로 데이터 전달 오류 발생  
타이밍 이슈: 비동기 호출 순서가 꼬이거나 충돌하는 경우  
의존성 충돌: 라이브러리 버전 차이로 인한 실행 오류  
환경 차이: 개발, 테스트, 운영 환경 간 설정 불일치로 생기는 문제  
통합 이슈 해결 프로세스  
이슈 식별 및 분류: 문제 증상과 영향을 파악해 우선순위 정리  
근본 원인 분석: 단순 증상 뒤에 있는 원인을 정확히 추적  
협업적 해결: 관련 팀 간 커뮤니케이션을 통해 근본적 해결책 도출  
검증 및 회귀 테스트: 수정된 기능이 전체 시스템에 영향을 주지 않는지 확인  
문서화 및 학습: 해결 과정을 기록해 재발 방지와 팀 지식 공유 

5. 통합 이슈 해결
PM이 통합 이슈 해결에 기여하는 부분  
이슈의 사업적 영향도를 고려해 우선순위를 조율  
프론트엔드, 백엔드, QA 등 관련 팀 간 원활한 조율과 소통 유도  
임시 해결책과 근본 해결책 사이의 균형 판단  
해결 소요에 따른 출시 일정 변경 또는 리스크 커뮤니케이션  
통합 이슈 해결 과정에서 자주 발생하는 문제  
책임 회피: 문제 소유권을 떠넘기며 지연되는 상황  
증상만 수정: 표면적인 증상만 해결하고 원인을 방치  
문서화 부족: 해결 내역이 남지 않아 같은 문제가 반복  
테스트 불충분: 수정 후 다른 기능까지 영향이 있는지 충분히 검증하지 않음

6. 최종 통합 승인
최종 통합 승인의 핵심 요소  
기능 완전성: 요구사항에 따라 기능이 모두 구현되었는지 확인  
품질 기준 충족: 주요 버그와 이슈가 해결되어 안정성이 확보되었는지 검토  
성능 목표 달성: 로딩 시간, 반응 속도 등 성능 측면에서 목표치를 만족하는지 평가  
사용자 경험 일관성: 화면 흐름과 인터랙션이 매끄럽고 일관되게 작동하는지 확인  
보안 및 규정 준수: 필수 보안 항목과 외부 규정(GDPR 등) 충족 여부 확인  
최종 통합 승인 프로세스  
통합 체크리스트 검토: 기능, 디자인, 에러 처리 등 필수 항목 전체 점검  
최종 사용자 시나리오 테스트: 대표적인 사용자 흐름을 기준으로 실제 사용성 확인  
이해관계자 승인 수집: QA, 사업팀, 개발팀 등 관련 부서의 승인 확보  
QA 이관 준비: QA 팀에 전달할 테스트 계획, 계정, 데이터 등 정리  
알려진 이슈 문서화: 미해결 사항을 기록하고 대응 계획을 포함해 공유 

6. 최종 통합 승인
PM이 최종 통합 승인에 기여하는 방식  
비즈니스 목표와 요구사항 기준으로 통합 결과를 평가  
기능/품질/일정 간 균형을 판단해 출시 가능성 결정  
각 부서 이해관계자에게 통합 상태를 명확히 공유하고 승인 확보  
QA 일정, 출시 커뮤니케이션 등 다음 단계를 사전에 조율  
최종 통합 승인 과정에서 자주 발생하는 문제  
불완전한 통합 상태에서 무리하게 승인을 진행  
일정 압박으로 인해 품질 기준이 낮춰짐  
중요한 사용자 시나리오나 엣지 케이스가 검증되지 않음  
이해관계자의 리뷰 없이 일방적으로 승인 절차를 마무리

PM은 ‘몰라도 되는 사람’이 아니다
PM은 제품의 전체 흐름을 조율하는 역할
개발 실무를 직접 수행하지 않더라도 주요 개념과 절차에 대한 이해는 필수적
디자인, 프론트엔드, 백엔드, 통합 단계 각각은 상호 의존적
각 파트의 구조, 흐름, 제약사항을 이해하고 상황에 맞는 질문과 조율을 할 수 있어야

PM이 모든 걸 알 수는 없지만무엇을 묻고, 언제 멈추고, 누구와 조율해야 하는지에 대해서는 아는 사람이어야 한다

그룹 연구(4인 1조)
각 조원은 디자인, 프론트엔드, 백엔드, 통합 중 하나의 프로세스를 선택하여 담당합니다.
조원들과 함께 논의하여, 각 파트별로 가장 이해하기 어려운 개념이나 요소를 하나씩 선정합니다.
선정된 개념에 대해 개별적으로 검색하고 조사하여, 그것이 무엇을 의미하는지 학습합니다.
각자 학습한 내용을 다른 조원들에게 쉽게 이해할 수 있도록 간단히 설명합니다.
설명한 내용 중 핵심적인 내용을 정리하여 요약본을 작성합니다.

질의응답 & 토론

사전 질문(15분)




수고하셨습니다
