프로젝트 관리(5)
실행 가능한 제품 설계

사전 질문(15분)
PRD 조율이 완료된 이후, 실제 개발을 시작하기 위해 PM은 어떤 자료와 정보를 추가로 준비해야 할까요?

개발팀이 MVP를 기획 의도에 맞게 구현할 수 있도록 하려면, PM은 어떤 수준까지 구체적으로 정의해야 할까요?

사전 질문 토론
✅ 1. PRD 조율 이후, 실제 개발을 위해 PM이 추가로 준비해야 할 자료와 정보는 무엇인가요?
개발자들이 혼란 없이 바로 작업할 수 있도록 기능 명세서, 화면 설계, API/DB 명세, 유저 플로우, 정책 정의, 테스트 시나리오 등을 구체화해야 한다.
우선순위, 일정, 담당자, 커뮤니케이션 체계가 명확히 정리되어야 하며, 의사결정 기준도 공유되어야 한다.
개발팀의 이해를 돕기 위한 기술 참고자료, 레퍼런스, 사용자 맥락 설명이 필요할 수 있다.
PRD에서 생략된 디테일한 예외처리, 경계조건, 사용자 입력 조건 등도 반드시 보완해야 한다.
✅ 2. 개발팀이 MVP를 기획 의도에 맞게 구현할 수 있도록, PM은 어떤 수준까지 정의해야 하나요?
개발팀이 질문 없이 구현에만 집중할 수 있을 정도로 상세하게 정의되어야 한다.
핵심 목적, 기능 우선순위, 사용자 시나리오, 성공 기준, 포함/제외 범위를 명확히 해야 한다.
"왜 이 기능이 필요한가"와 "사용자가 어떤 가치를 느껴야 하는가"에 대해 공통된 인식을 만드는 것이 핵심이다.
기능의 흐름뿐 아니라 기술적 조건, 성능 요구사항, 보안/안정성 수준까지 고려해야 한다.

Case: 문서를 무수히 만들지만 오류는 여전히
새로운 서비스 개발을 위해 기획팀이 문서를 작성하기 시작
필요한 모든 파트에 대해 상세 정책 문서를 만드는 것을 목표
수많은 레퍼런스 조사, 법률 검토, 기존 서비스 검토 등등
필요한 정책 문서를 모두 만들었지만 개발팀에서는 이를 이해하지 못함
상세 정책에 대해 모두 정의내렸음에도 여전히 정의되지 않은 케이스들이 발생
이 문제를 해결하기 위해 기획팀이 밤을 새워 문서를 만들어도 문제가 해소되지 않음

PRD의 목적에서 출발할 필요가 있다
구성원들간의 조율로 만들어진 PRD 문서 -> MVP의 방향을 설정
이를 만드는 과정에서 디자이너, 개발자 들이 확실하게 해야 하는 부분들이 존재
실제 서비스 안에서 이런 기능들이 구체적으로 어떻게 돌아가는가?

최종 목적은 ‘고객'이 이 기능을 통해 ‘가치'를 느끼게 되는 것
정책을 정하고 문서를 만드는 것이 목표가 아니다 -> 고객이 사용하는데 어려움이 없어야
프로토타입에 기반하여 개발팀이 이런 목표를 달성하기 위해 필요한 문서를 추가로 제공해줘야할 필요가 있다

PRD의 목적과 한계
PRD는 주로 '무엇을'(What) 만들지를 정의하는 문서
비즈니스 가치와 핵심 기능에 초점을 맞춤
모든 상황과 맥락을 담기에는 한계가 있음
문서는 읽는 사람의 배경과 경험에 따라 다르게 해석됨


구현에 필요한 추가 정보
사용자가 실제로 경험하는 전체 여정과 흐름
각 화면과 기능이 다양한 상황에서 어떻게 동작해야 하는지
비즈니스 규칙과 정책에 따른 구체적인 동작 방식
예외 상황에서의 처리 방안과 사용자 안내

실행 가능한 제품 설계의 핵심 요소
1. 정보 구조화(IA)와 사용자 흐름 정의
제품 전체 구조에서 기능의 위치와 관계 정의
사용자 목표 달성을 위한 단계별 여정 설계
2. 화면 상태와 전환 조건 구체화
각 화면의 다양한 상태와 변화 조건 정의
입력 요소의 유효성과 피드백 방식 설계
3. 비즈니스 정책과 규칙 명확화
데이터 처리와 표시에 대한 구체적 규칙 정의
시스템 동작의 논리적 기준과 제약 조건 설정
4. 예외 상황과 오류 처리 방안 정의
일반적 흐름을 벗어나는 상황 식별
사용자 관점에서의 오류 처리와 복구 경로 설계

IA(Information Architecture)란?
사용자가 디지털 제품 내에서 정보를 쉽게 찾고 이해할 수 있도록 정보의 구조와 흐름을 설계하는 작업입니다.
❌ 단순한 메뉴 구성이 아님
IA는 내비게이션 구성에 그치지 않는다
사용자의 목적과 맥락에 맞는 정보 구조 전반을 설계하는 일
메뉴, 카테고리, 라벨, 화면 간 흐름 등 정보 소비 방식 전체에 영향


핵심 구성 요소
조직화 구조 (Organization): 기능/화면/콘텐츠의 분류 및 계층화
레이블링 (Labeling): 사용자가 의미를 직관적으로 이해할 수 있는 명칭 사용
탐색 시스템 (Navigation): 사용자가 정보를 찾아 이동하는 구조
검색 시스템 (Search): 원하는 정보에 빠르게 접근할 수 있는 검색 구조
좋은 IA는 사용자가 "이 다음에 뭘 하면 되지?"라고 묻지 않게 만든다.

왜 IA가 중요한가?
정보가 잘 구조화되지 않으면, 사용자는 기능이 있어도 사용하지 못하거나, 찾지 못하거나, 떠난다.
"디자인은 했는데 사용자들이 기능을 못 찾아요"
"홈 화면에 다 있어요, 그런데 아무도 안 써요"
"검색만 의존하고, 구조가 없어요"
"메뉴 명칭이 우리끼리만 아는 용어예요"

IA가 잘 된 경우
사용자 여정이 매끄럽고, 다음 단계가 자연스럽게 유도됨
다단계 기능이라도 혼란 없이 목적을 달성할 수 있음
디자이너가 전체 맥락을 고려해 화면을 구성함
구조가 명확해 QA 및 CS에서도 일관된 이해 가능
“IA는 단순한 ‘메뉴 설계’가 아닌 '기능이 존재하는 것'과 '사용자가 도달할 수 있는 것' 사이의 간극을 메우는 설계이다.”

잘못된 IA 사례 vs. 개선된 IA 사례
❌ 잘못된 IA 사례: 기능은 있으나 도달 불가
문제 상황:
사용자가 송금 기능을 찾기 어려움
홈 화면엔 배너와 추천 콘텐츠만 있음
‘송금’ 메뉴는 ‘더보기 > 금융도구 > 기타’에 위치
화면은 예쁘지만 사용 흐름과 연결되지 않음
결과:
기능 활용률 저조
사용자는 앱을 “불편하다”고 인식
CS 및 이탈률 증가

잘못된 IA 사례 vs. 개선된 IA 사례
✅ 개선된 IA 사례: 사용자 흐름 중심의 구조
개선 포인트:
홈 화면 상단에 자주 쓰는 기능 → ‘빠른 송금’ 바로가기 배치
‘송금’ 메뉴는 ‘내 계좌 > 자산 관리 > 송금’의 명확한 위치로 이동
사용자 행동 데이터 기반으로 메뉴 순서 정렬
메뉴 명칭을 내부 용어가 아닌 사용자 언어로 수정 (예: '이체도우미' → '송금')
결과:
기능 접근성 개선 → 사용률 상승
사용자 만족도 향상, 문의 감소
PM과 디자이너 간 구조 정렬로 반복 수정 줄어듦

IA를 PM과 디자이너의 협업에 활용하려면?
디자이너는 단순히 화면을 그리는 사람이 아니다.
IA를 기반으로 사용자 흐름과 정보 구조를 시각적으로 구체화하는 파트너다.
PM이 IA 기반으로 디자이너와 협업할 때 해야 할 질문:
이 기능은 사용자에게 어디에서, 왜, 어떻게 도달해야 할까?
이 화면은 어떤 상위 기능 구조에 속하는가?
사용자가 이 위치에 도달했을 때, 어떤 선택지와 흐름이 제시되어야 할까?
기능은 존재하는가가 아니라, 발견 가능한가(findable)?
사용자가 다음 단계를 예측할 수 있을 정도로 구조화되어 있는가?

작성 전 확인 사항
이 기능은 사용자에게 어떤 목표를 달성하게 하는가?: 기능 중심이 아닌 목적 중심 사고 유도
사용자는 어떤 흐름으로 이 기능에 도달하는가?: 메뉴 구조와 접근성을 결정
기능은 어떤 상태를 가지며, 상태 전환 조건은 무엇인가?: 화면 구성 기준이 됨
예외 상황은 무엇이며, 어떻게 처리되어야 하는가?: 사용자 혼란 방지, UX 안정성 확보

User Flow란?
사용자가 특정 목표를 달성하기 위해 제품 내에서 거치는 행동 경로와 상태 전이 과정을 시각화한 구조도입니다.
단순한 “홈 → 로그인 → 완료” 순서가 아니라 사용자의 의도, 선택, 조건, 심리적 맥락까지 고려된 전체 경험의 흐름 설계
📌 왜 중요한가?
사용자 중심의 설계를 위한 출발점
팀 전체가 같은 사용자 시나리오를 공유할 수 있는 수단
기능 단위 기획을 넘어, 목표 단위 사고 전환 가능


화면 흐름(Screen Flow)과 사용자 흐름(User Flow)
기준: 화면 전환 구조 vs 사용자 목표 달성 과정
중심: 기능 또는 UI 구성 vs 사용자 행동 및 의사결정
구성: A → B → C 화면 vs 선택지, 분기점, 조건 포함
목적: 화면 연결 흐름 파악 vs 실제 사용 시나리오 검토 및 설계

User Flow는 어떤 정보를 담아야 하는가?
1. 사용자 목표
사용자가 이 기능을 통해 달성하려는 최종 목적
ex) “친구에게 빠르게 돈을 보낸다”
2. 핵심 행동 경로 (Happy Path)
가장 이상적인 시나리오
ex) 홈 → 수취인 선택 → 금액 입력 → 인증 → 완료
3. 의사결정 포인트 (Decision Point)
사용자 선택에 따라 흐름이 분기되는 지점
ex) 연락처에서 선택 vs 계좌번호 직접 입력

User Flow는 어떤 정보를 담아야 하는가?
4. 조건/예외 흐름 포함
정상 흐름 외에 예외 상황 대응 경로
ex) 잔액 부족, 인증 실패, 서버 오류 등
5. 시스템 상태 및 피드백
입력 결과에 따라 화면이나 시스템이 제공하는 반응
ex) 오류 메시지, 로딩 상태, 성공 알림

실무에서 User Flow는 어떻게 사용되는가?
디자이너에게 설계 의도 전달→ 사용자 중심의 흐름을 기반으로 UI를 설계 가능
개발자에게 흐름 조건 공유→ 로직 분기와 상태 관리 기준을 명확히 이해
QA에게 테스트 시나리오의 기준 제공→ Happy Path + 예외 흐름 포함한 검증 가능
CS와 공유하여 고객 응대 흐름 정렬→ 어디에서 문제가 발생할 수 있는지 사전 인지

User Flow 작성 팁
1. 사용자 목표로 시작하라: ‘기능 흐름’이 아닌 ‘사용자 여정’ 중심으로 구성
2. 실제 분기와 조건을 명시하라: 예외 없이 단선적인 흐름은 현실과 맞지 않음
3. 시스템 상태를 생략하지 말라: 로딩, 실패, 제한 조건 등 모두 설계의 일부
4. 비주얼로 표현하되 말로도 설명하라: 도해 + 짧은 설명문 병행이 가장 효과적
5. 협업 툴을 활용하라: Miro, Figma, Lucidchart 등으로 실시간 피드백 가능

정책 설계란?

화면에 표현된 요소들이 실제 어떤 조건에서, 어떤 방식으로 동작해야 하는지를 정의
왜 필요한가?
동일한 화면이라도 입력 값, 네트워크 상황, 사용자 등급에 따라 동작이 달라짐
디자이너와 개발자는 보이지 않는 조건을 알 수 없음
‘화면이 나왔는데도 원하는 동작이 구현되지 않는’ 상황을 방지
비즈니스 정책을 UI 흐름에 반영해야 일관된 제품 경험 제공 가능

디자이너와의 협업 방식
프로토타입(Figma 등)에 상태별 조건을 주석 또는 노트로 직접 작성
복잡한 로직은 상태 매트릭스 또는 결정 테이블 형태로 별도 정리
시스템 반응을 텍스트만으로 설명하지 말고 시나리오와 함께 전달

프로토타입 이후 단계에서 정의해야 할 정보 구조
UI 상태 정의 (UI States / 컴포넌트 상태 설명)
입력 및 행위 조건 정의 (Validation Rules)
업무 및 비즈니스 정책 정의 (Business Rules)
조건 조합 결과 정의 (결정 테이블)
예외 흐름 정의 (Edge Case Flow)
오류 및 시스템 피드백 설계 (Error UX)

Break Time

1. UI 상태 정의 (UI States / 컴포넌트 상태 설명)
하나의 화면 혹은 컴포넌트가 여러 가지 상황에 따라 시각적으로 또는 기능적으로 달라지는 모습을 말합니다.
“금액 입력 필드”라는 동일한 화면 요소라도 입력이 없을 때, 입력 중일 때, 오류일 때, 로딩 중일 때의 모양과 작동 방식은 달라야 합니다.
왜 필요한가?
디자이너가 모든 상태를 다 그리지 않으면 개발자가 임의로 판단함
기획자는 happy path만 작성하고 예외 상태를 빠뜨리는 경우가 많음
QA는 명확한 상태 정의가 없으면 무엇이 정상인지 모르고 테스트함
상태가 정의되지 않으면 컴포넌트 단위 재사용이나 디자인 시스템화가 불가능

실무 협업에서 일어나는 문제 예시
입력창에 값이 없을 때: 버튼이 비활성화되어야 하는데, 설계가 없어 기능 작동함
오류 발생 시: 어떤 메시지가 나와야 하는지, 어디에 띄워야 하는지 모름
로딩 중 상태: 버튼이 회전하는지, 비활성화되는지, 스켈레톤 로딩인지 논의 필요
선택형 버튼: 어떤 상태가 선택인지 아닌지 시각적 기준이 없음

실무에서 구분해야 할 상태 종류
입력 상태 (Input States): 사용자가 입력 중일 때, 유효/무효 여부에 따라 바뀌는 UI 상태
시스템 상태 (System Response): 처리 중, 완료, 실패 등 시스템이 주도하는 상태
피드백 상태 (Feedback States): 성공, 실패, 주의 등 사용자에게 전달되는 메시지 중심 상태
디폴트 상태 (Default / Empty): 초기 진입 시 아무 데이터도 없을 때의 상태
에러 상태 (Error States): 시스템 오류, 입력 오류 등 예외 발생 시

실무 작성 방식 예시
금액 입력 컴포넌트의 상태 정의

실무 작성 팁
초기/입력중/완료는 무조건 명시: 상태 구분이 없으면 디폴트만 개발됨
모든 입력 필드는 유효/무효 상태를 가짐: Validation 정의와 연결됨
오류는 항상 시각적 피드백 + 메시지 + 동작 차단 포함: 세 가지 요소 빠짐없이 기획
상태가 전환되는 조건을 함께 정의: 어떤 액션/조건에서 상태가 바뀌는지 꼭 명시
UI마다 상태 정의는 표 형태로 통일: 문서 전체 일관성 확보 및 이해 용이

2. 입력 조건 및 유효성 규칙 (Validation Rules)
입력 조건은 사용자가 입력 필드나 인터랙션 요소를 사용할 때 허용되는 값의 기준과 제약을 정의하는 것입니다.
단순한 숫자/문자 입력 여부를 넘어서, 기능이 작동하기 위한 최소한의 전제 조건을 설계하는 단계입니다.
왜 필요한가?
조건이 정의되지 않으면 디자이너는 UI 요소 상태를 설계하지 못하고 개발자는 로직을 구현하며 임의로 판단하게 됨
사용자가 잘못된 입력을 했을 때 무엇이 잘못됐는지 알 수 없고, 기능도 제대로 작동하지 않아 사용자 경험이 붕괴
입력 조건이 명확해야 에러 발생 시 사용자 안내 → 복구 가능 UX 설계 가능

입력 조건의 주요 구성 요소
허용 타입: 숫자, 영문, 이메일 등 입력 가능한 데이터의 형식ex) 숫자만 입력 가능, 이메일 형식 등
범위: 최소/최대값 또는 길이 제한ex) 1,000원 이상, 6자리 숫자
형식 포맷: 입력값의 시각적/문자적 규칙ex) 천 단위 콤마, 하이픈 자동 삽입 등
실시간 검증: 입력 중 조건 위반 여부를 즉시 확인ex) 형식 오류 시 빨간 테두리 및 메시지 표시
조건 충족 후 동작: 조건 만족 시 다음 단계 또는 버튼 활성화ex) 입력 완료 시 '다음' 버튼 활성화

Validation의 유형
형식 검증 (Format): 특정 패턴에 맞는지 확인ex) 이메일 주소, 전화번호, 숫자
범위 검증 (Range): 값이 정해진 범위 안에 있는지 확인ex) 1,000원 이상, 6자리 이하
필수 항목 (Required): 반드시 입력되어야 하는지 여부ex) 약관 동의 체크박스
논리 검증 (Logical)	: 비즈니스 로직에 따른 조건ex) 잔액보다 큰 금액 불가
중복/정합성 검증: 다른 정보와 일치 또는 중복 여부 확인ex) 비밀번호 재입력 일치 확인

실무 예시: 송금 기능의 금액 입력 필드

입력 조건 설계 시 유의사항
조건은 명확하고 수치화되어야 함: “적당히”, “충분히”는 금지. 수치로 표현
사용자의 행동 결과를 예측할 수 있도록 설계: 잘못된 입력 시 어떤 일이 일어나는지 명확히 안내
형식 제한 + 메시지 + 동작 차단은 항상 함께: 제한만 있으면 당황, 메시지만 있으면 혼란

3. 업무 및 비즈니스 정책 정의 (Business Rules)
비즈니스 정책은 제품이 일관되게 동작하도록 하기 위해, 회사나 서비스 차원에서 정한 규칙이나 제약 조건입니다.
입력 조건이 "사용자의 행위 제한"이라면, 정책은 "서비스가 기능을 허용할지 결정하는 기준"입니다.
왜 중요한가?
제품이 일관된 방식으로 작동하려면 명확한 기준이 필요합니다.
개발자가 기능 구현 중 “이럴 땐 어떻게 해야 하지?”라는 의사결정 공백이 생기지 않게 합니다.
법적, 보안적, 혹은 비즈니스 전략상 필요한 동작을 기술적으로 반영하는 기준이 됩니다.
정책이 없거나 불명확하면, 각 담당자가 임의로 판단하게 되고 결과가 뒤틀립니다.

정책과 조건의 차이
항목
조건 (Validation)	
정책 (Business Rule)
목적
사용자의 입력을 제한
기능 동작의 기준을 제시
적용 시점
UI 상 입력 단계
기능 수행 전 또는 중간
작성 기준
수치, 포맷 중심
서비스 기준, 법적 요건 등
예시
1,000원 이상만 입력 가능
VIP 등급만 1,000만원 송금 허용

정책의 주요 구성 요소
정책 ID: 정책을 식별할 수 있는 코드 (예: TRANS-001)
정책명: 해당 정책의 목적 또는 영역을 명확히 나타낸 이름
목적: 왜 이 정책이 필요한지, 해결하고자 하는 문제
적용 범위: 어떤 기능, 화면, 사용자군에 적용되는지
조건 및 내용: 정책이 발동되는 조건, 실행 시 동작 방식
예외 규정: 특수 상황에서 정책이 변경되는 경우
변경 이력: 정책 변경 또는 폐기 시 기록용

정책 정의 예시
[정책 ID]: TRANS-001[정책명]: 송금 한도 정책[목적]: 등급별 송금 한도를 설정하여 사기 방지 및 금융 리스크 완화[적용 대상]: 모든 송금 기능 사용자
[정책 내용]
일반 사용자: 1회 최대 300만원, 일일 500만원
우수 사용자: 1회 최대 500만원, 일일 1,000만원
VIP 사용자: 1회 최대 1,000만원, 일일 2,000만원
[예외 규정]
인증 수단 강화 시 한도 최대 2배까지 임시 상향 가능
계정 이상 징후 감지 시 임시 한도 제한 적용
[변경 이력]
2025-01-01: VIP 등급 한도 상향 (기존 700만원 → 1,000만원)

정책 정의 시 유의할 점
“서비스가 왜 이렇게 동작하는가”를 설명: 단순 제약 나열이 아닌, 이유와 목적 포함
구체적인 수치와 조건을 명시해야 함: “적절한 수준” → “1,000만원 이하”로 표현
QA 테스트가 가능하도록 명세 형태로 작성: 정책마다 테스트 시나리오가 도출되어야 함
예외 상황까지 반드시 정의: 없는 경우 실무에서 임의 처리 발생 가능성 높음
정책은 버전 관리가 필수: 정책은 바뀔 수 있음 → 추적 가능하게 관리 필요

정책과 사용자 경험의 관계
정책은 사용자에게 보이지 않지만, 사용자 경험을 결정짓는 요인입니다.
정책에 따라 어떤 기능은 허용되고, 어떤 사용자는 차단되며, 어떤 경고가 뜨는지가 달라집니다.
따라서 정책 정의는 UI/UX 설계, 기술 구현, 고객 지원 프로세스까지 전방위적 영향을 미칩니다.

4. 조건 조합 결과 정의 (결정 테이블)
결정 테이블은 여러 조건이 동시에 작용할 때 어떤 결과가 도출되어야 하는지를 체계적으로 정리한 표입니다.
복잡한 정책이나 로직이 있을 때, 조건의 조합별로 행동을 명확히 정의함으로써
개발자, QA, 디자이너 모두가 혼란 없이 같은 결과를 도출할 수 있게 합니다.
왜 필요한가?
조건이 2개 이상 복합적으로 적용될 때 로직이 꼬이거나 빠지기 쉬움
구두 설명이나 문장만으로는 모든 케이스를 빠짐없이 설명하기 어려움
QA의 테스트 시나리오, 개발자의 조건 분기 처리, 디자이너의 예외 설계까지 공통 기준점 제공
조건 충돌/중복 여부를 논리적으로 검토 가능 (테이블이기 때문에 빠짐/충돌 검출 가능)

예시: 송금 수수료 결정 테이블

구성 요소
조건 항목: 분기 판단의 기준이 되는 변수 (등급, 시간대 등)
결과 항목: 조건의 조합에 따라 출력되거나 실행되는 결과 (수수료, 권한 등)
규칙 ID: 각 행의 고유 식별자. 정책 변경이나 테스트 추적에 사용
와일드카드: ‘전체’ 또는 ‘무관’ 등을 써서 조건 생략 가능 (단 명확하게 정의해야 함)

언제 쓰는가?
조건이 많고 경우의 수가 폭증할 때: 3개 조건만 있어도 2×2×2 = 8가지 조합 발생
정책 변경이 잦아 검토가 필요한 경우: 등급 정책 개편, 시간대 정의 변경 등
QA에서 테스트 누락을 방지하고 싶을 때: 모든 조합을 하나의 테이블에서 검토 가능
개발자와 구현 로직 논의 시 기준이 필요할 때: if 조건이 중첩되는 경우 시각적으로 정리

실무 작성 팁
조건 항목은 최대한 독립 변수로 구성: 서로 영향을 주는 항목은 우선 분리
규칙 ID는 QA/개발 테스트에서 반드시 사용: R1, R2… 형태로 명시하면 추적 및 이슈 리포팅 용이
공통 결과는 그룹핑 또는 기본값 지정: 중복된 결과를 묶거나 별도 규칙으로 처리
변경/추가가 쉬운 포맷 사용: Google Sheet 등으로 관리하면 정책 변화 대응 유연

정책 정의 vs 결정 테이블
형식: 서술형 문서 vs 표 형식
목적: 각 규칙의 이유와 범위를 설명 vs다양한 조건 조합의 결과를 정리
적용 시점: 설계/기획 단계 vs 구현/테스트/검토 단계
특징: 기준이 되는 원칙 제공 vs 로직별 예외 조합까지 명확히 분류 가능

5. 예외 흐름 정의 (Edge Case Flow)
예외 흐름은 사용자가 일반적인 흐름(Happy Path)을 따르지 못하거나, 시스템이 비정상적인 상황에 직면했을 때 작동하는 대체 흐름을 말합니다.
엣지 케이스는 확률은 낮지만 발생 시 치명적일 수 있는 비정형 상황을 의미합니다. (ex. 인증 실패 3회, 세션 만료, 서버 지연, 중복 요청 등)
왜 중요한가?
실제 사용자의 대부분은 예외 상황을 겪는다.
예외 대응이 없거나 허술하면, 사용자가 포기하거나 시스템 오류로 이어짐
CS/QA 이슈의 대부분이 예외 상황에서 발생
제품의 신뢰성과 완성도를 결정짓는 핵심 요소

예외 흐름 설계의 기본 구성
예외 상황 ID: 고유 식별자 (Ex: E001)
발생 조건: 어떤 조건에서 발생하는지
영향: 사용자가 어떤 문제를 겪는지
처리 방안: 시스템/사용자에게 어떤 조치를 취할 것인지
사용자 메시지: 어떤 메시지/안내를 보여줄 것인지
복구 가능 여부: 재시도 가능, 수동 조치 필요 여부

예시: 송금 기능의 예외 흐름 테이블

엣지 케이스 예시

사용자 관점에서 예외 설계하기
명확한 원인 안내: “잘못되었습니다” → ❌ / “인증번호가 틀렸습니다” → ✅
복구 유도: 취소/다시 시도 버튼, 이전 단계로 복귀 등
시스템 책임 강조: 사용자 잘못 아님을 명확히 (서버 오류 시)
지속적 상태 유지: 중단된 상태에서도 정보가 보존되도록 설계 (ex: 금액 입력 후 중단 → 다시 시작 시 유지)

6. 오류 및 시스템 피드백 설계 (Error UX)
사용자가 예상하지 못한 결과를 마주했을 때, 시스템이 전달하는 메시지와 반응 방식은 그 제품의 신뢰도, 사용성, 브랜드 이미지에 직접적인 영향을 줍니다.
오류 메시지 설계는 단순 안내 문구 작성이 아니라, 사용자가 다음에 무엇을 할 수 있는지를 명확히 알려주는 행동 안내 설계입니다.
왜 중요한가?
대부분의 사용자는 정상 흐름이 아닌 상태에서 제품을 기억함
"에러가 났다"보다 **"에러가 났을 때 어떻게 대응했는가"**가 더 중요한 경험
애매한 피드백은 혼란, 포기, CS 유입으로 이어짐
명확한 메시지와 복구 안내는 사용자 불안 해소와 재시도 유도에 핵심

실무 설계 시 고려할 요소
상황 인식: 어떤 조건에서 발생했는지 정확히 표현
원인 명확화: 사용자 책임 vs 시스템 오류 구분
행동 제안: "다시 시도", "고객센터 문의", "뒤로 가기" 등 다음 행동을 안내
시각적 구분ㅣ 오류/성공 상태를 시각적으로 명확히 구분 (색상, 아이콘 등)
정서적 톤: 비난/경고가 아닌, 안내/지원의 톤으로 설계

오류 메시지 유형별 예시
입력 오류: 원인 명확히 제시 + 입력 수정 유도 - "이메일 형식이 올바르지 않습니다."
인증 실패: 사용자 실수 명확화 + 재입력 유도 - "인증번호가 일치하지 않습니다. 다시 입력해주세요."	
시스템 오류: 복구 불가한 상황에서의 안내 - "잠시 후 다시 시도해주세요. (오류코드: 503)"
연결 실패: 사용자 조치가 가능한 경우 - "네트워크 상태가 불안정합니다. 연결을 확인해주세요."
제한 초과: 정책 기반 안내 + 해결책 제시 - "오늘의 송금 한도를 초과했습니다."	
성공 피드백: 완료 후 신뢰 강화 + 다음 행동 유도 - "송금이 완료되었습니다. 내역에서 확인하실 수 있어요."

실무 예시: 메시지 매트릭스

실무 설계 팁
사용자 책임 여부 구분: "잘못된 입력"과 "시스템 오류"는 명확히 구분하여 표현
에러코드 제공: 반복 이슈 시 CS 대응을 위한 코드 삽입 (Ex: E503)
시각적 패턴 통일: 오류: 빨강, 성공: 초록, 경고: 노랑 등 일관성 유지
재시도 가능성 포함: 가능할 경우 ‘다시 시도’ 버튼 기본 제공
모바일 대응: 화면 공간 제한 고려 → 요약 메시지 + 상세 팝업 분리

린 환경에서의 기획 정보 전달 원칙
1. 점진적 상세화 전략
처음부터 모든 것을 완벽하게 정의하지 않음
개발 단계에 맞춰 필요한 정보를 적시에 제공
초기에는 핵심 흐름과 주요 화면에 집중
반복적인 피드백과 개선을 통한 진화
2. 우선순위 기반 접근
모든 상태와 예외를 동일하게 취급하지 않음
비즈니스 가치와 사용자 영향도에 따른 우선순위 설정
P0(필수), P1(중요), P2(선택) 등으로 구분
핵심(P0)에 집중하고 나머지는 점진적으로 해결

린 환경에서의 기획 정보 전달 원칙
3. 문서와 소통의 균형
문서화와 대화 중 더 효과적인 방식 선택
복잡한 로직과 규칙은 문서화, 맥락과 의도는 대화로 전달
시각적 도구를 활용한 효율적 커뮤니케이션
장황한 설명보다 명확한 예시와 시연 활용
4. 협업 툴의 전략적 활용
Figma, Miro 등 실시간 협업 도구로 효율성 증대
모든 이해관계자가 접근 가능한 중앙화된 정보 관리
변경사항의 실시간 공유와 피드백
문서 관리 오버헤드 감소

린 환경에서의 기획 정보 전달 원칙
5. 지속적인 참여 모델
문서 전달 후 "담 넘기기"가 아닌 지속적 협업
개발 과정 전반에 걸친 PM의 참여와 피드백
짧은 피드백 루프를 통한 빠른 조정
정기적인 리뷰와 학습 사이클 운영

제품 설계 문서는 필요한 내용을 ‘기획'하는 것이 목적이 아닌, MVP의 목적을 달성하는 데 필요한 구체적인 사항들을 협의하는 것에 있다

그룹 연구(3인 1조)
세 명 중 한 명은 PM, 한 명은 디자이너, 한 명은 개발자 역할을 맡습니다.
PM이 선택한 앱 서비스에서 주요 메뉴 하나를 지정하고, 그 메뉴의 핵심 기능을 기준으로 다음 역할을 수행합니다:
PM: 해당 메뉴의 디자인 방향과 정책을 정리할 수 있는 구조를 설계합니다.
디자이너: 해당 메뉴에 대한 IA(정보 구조)와 User Flow(사용자 흐름)를 도식화하고 정리합니다.
개발자: 해당 메뉴의 주요 기능에 필요한 정책, 조건, 예외 흐름 등 구현 관점의 정보를 정리합니다.
주어진 시간 동안, 각자 역할에 맞는 정보를 문서로 구성하고, PM이 이 자료들을 하나로 통합해 연결된 기획 문서로 구성합니다.
작성 과정에서 각자의 고민과 인사이트를 공유하고, 이를 바탕으로 정리된 협업 결과물을 도출합니다.

질의응답 & 토론

사전 질문(15분)
PRD 조율이 완료된 이후, 실제 개발을 시작하기 위해 PM은 어떤 자료와 정보를 추가로 준비해야 할까요?

개발팀이 MVP를 기획 의도에 맞게 구현할 수 있도록 하려면, PM은 어떤 수준까지 구체적으로 정의해야 할까요?

수고하셨습니다
