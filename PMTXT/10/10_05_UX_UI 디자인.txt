UX/UI 디자인(5)
인터랙션과 인터페이스 설계

사전 질문(15분)
눈에 잘 들어오고 소통에 어려움이 없는 UI는 어떤 특징들이 있을까요? 반대로 사용하기 어려웠던 UI는 무엇이 문제였을까요?

정보를 입력하고 싶은 UI와 그렇지 않은 UI는 어떤 차이가 존재할까요? 

사전 질문 토론
1. 눈에 잘 들어오고 소통에 어려움이 없는 UI는 어떤 특징들이 있을까요?
좋은 UI는 직관적이고 눈에 잘 들어오며, 내가 뭘 해야 할지 자연스럽게 알 수 있어야 한다.
화면이 너무 복잡하거나 버튼이 어디에 있는지 몰라 헤매게 되면 그건 나쁜 UI다.
기능보다 디자인만 앞서거나, 정보를 억지로 다 보여주려는 경우도 불편함을 만든다.
결국 사용자의 시선 흐름과 행동을 고려한 설계가 핵심이라고 생각한다.
2. 정보를 입력하고 싶은 UI와 그렇지 않은 UI는 어떤 차이가 존재할까요?
입력하고 싶은 UI는 구조가 간결하고, 내가 뭘 입력해야 하는지 명확하게 보여준다.
입력 흐름이 자연스럽고, 중간중간 피드백이 오면 신뢰가 생기고 부담이 줄어든다.
반면 입력란이 많거나 복잡하면 귀찮고, 입력 후에 뭘 얻는지도 안 보이면 꺼려지게 된다.
결국 내가 왜 입력해야 하는지, 그 결과가 뭔지 납득이 가야 손이 움직인다.

인터랙션은 대화다
좋은 대화를 생각해보세요
내가 말하면 → 상대가 고개를 끄덕입니다
이해했다는 표정을 짓습니다
적절한 답변이 돌아옵니다
대화가 자연스럽게 이어집니다
인터페이스도 똑같습니다
사용자가 클릭하면 → 버튼이 눌린 모습을 보입니다
로딩 중임을 표시합니다
결과를 보여줍니다
다음 행동으로 자연스럽게 유도합니다

Microinteractions: 마이크로 인터렉션
Microinteraction이란?
정의: 하나의 작업을 중심으로 하는 작은 제품의 순간들
알람 설정하기
좋아요 누르기
새로고침하기
볼륨 조절하기
왜 중요한가?
신뢰 구축: "시스템이 내 행동을 이해했구나"
즐거움 제공: 단순한 작업도 즐겁게
브랜드 차별화: 같은 기능, 다른 느낌
에러 방지: 명확한 피드백으로 실수 줄이기

Facebook 좋아요 버튼의 진화
2009년 초기 버전
클릭 → "Like" 텍스트가 "Unlike"로 변경
2024년 현재
클릭 → 하트가 빨간색으로 변하며
작은 하트들이 터지는 애니메이션
진동 피드백 (모바일)
숫자가 올라가는 모션
완료 후 잔상 효과
감정적 만족감을 제공하기 위해서
"내가 좋아요를 눌렀고, 시스템이 그걸 확실히 받아들였으며, 그게 의미 있는 행동이었다"

Microinteractions의 4단계 구조
1. Trigger (트리거): 마이크로인터랙션을 '발동'시키는 계기입니다.
Manual Trigger (사용자가 시작)
버튼을 누를 때
스위치를 켤 때
음성 명령을 할 때
좋은 Manual Trigger는 발견하기 쉬워야 합니다. 
System Trigger (시스템이 시작)
오전 8시 알람
새 메시지 도착
배터리 부족 경고
너무 자주 발생하면 스팸이 되고, 너무 뜸하면 존재감이 없어집니다.

Microinteractions의 4단계 구조
2. Rules (규칙): "트리거가 발생했을 때 정확히 무엇이 어떻게 일어나는가"
좋아요 버튼:
상황 1: 로그인 + 좋아요 안 한 상태→ 좋아요 추가, 카운트 1 증가, 서버에 전송
상황 2: 로그인 + 이미 좋아요→ 좋아요 취소, 카운트 1 감소, 서버에 전송
상황 3: 비로그인→ 로그인 모달 표시
상황 4: 네트워크 오류→ 일단 UI 변경, 백그라운드 재시도

Microinteractions의 4단계 구조
3. Feedback (피드백): 시스템이 사용자에게 "말하는" 방식입니다.
피드백의 타이밍별 역할
0-100ms: "들었어요"
버튼이 눌린 모습, 호버 시 색상 변화, 터치 시 리플 효과
이 즉각적인 반응이 없으면 사용자는 불안해합니다. "내가 제대로 누른 건가?"
100ms-1s: "처리하고 있어요"
로딩 스피너, 프로그레스 바, "저장 중..." 메시지
여기서 중요한 건 왜 기다려야 하는지 알려주는 것입니다.
1s 이후: "완료했어요"
✓ 체크 표시, "성공적으로 저장되었습니다", 다음 단계로 자동 이동
완료 피드백은 단순한 확인을 넘어 다음 행동을 안내해야 합니다.

Microinteractions의 4단계 구조
3. Feedback (피드백): 시스템이 사용자에게 "말하는" 방식입니다.
피드백의 타이밍별 역할
0-100ms: "들었어요"
버튼이 눌린 모습, 호버 시 색상 변화, 터치 시 리플 효과
이 즉각적인 반응이 없으면 사용자는 불안해합니다. "내가 제대로 누른 건가?"
100ms-1s: "처리하고 있어요"
로딩 스피너, 프로그레스 바, "저장 중..." 메시지
여기서 중요한 건 왜 기다려야 하는지 알려주는 것입니다.
1s 이후: "완료했어요"
✓ 체크 표시, "성공적으로 저장되었습니다", 다음 단계로 자동 이동
완료 피드백은 단순한 확인을 넘어 다음 행동을 안내해야 합니다.

Microinteractions의 4단계 구조
4. Loops & Modes: 시간에 따라 진화합니다.
Loop (반복)
알람은 몇 분마다 울릴까?
스누즈는 몇 번까지 허용할까?
애니메이션은 한 번? 반복?
Mode (모드)
첫 사용자 vs 숙련자
평상시 vs 방해금지 모드
낮은 배터리 vs 충분한 배터리
Instagram 스토리 알림의 Mode 변화:
처음: "친구가 새 스토리를 올렸어요!" (적극적)
자주 무시하면: 조용히 표시만 (소극적)
다시 관심 보이면: 알림 재개 (적응적)

마이크로인터랙션 설계 원칙
1. 인간적이어야 한다
기계적 반응 ❌: "ERROR 404"
인간적 반응 ✅: "앗, 페이지를 찾을 수 없네요"
2. 예측 가능해야 한다
같은 행동 = 같은 결과
패턴을 학습할 수 있도록
예외는 명확히 설명

마이크로인터랙션 설계 원칙
3. 효율적이어야 한다
필요 이상으로 화려하지 않게
반복 사용 시 지루하지 않게
생략 가능한 옵션 제공
4. 즐거워야 한다
작은 디테일로 미소 짓게
브랜드 개성 표현
사용할수록 애착 형성

Form Design: 사용자가 포기하지 않는 입력 양식
Form이 중요한 이유 - 사용자와 비즈니스의 접점
회원가입 → 사용자 확보
결제 정보 → 매출 발생
문의 양식 → 고객 소통
충격적 통계:
Form 이탈률 평균 67%
필드 하나 줄이면 전환율 26% 상승
로딩 1초 지연 시 이탈률 20% 증가
💡 핵심: Form 디자인이 곧 비즈니스 성과

Form Design의 첫 번째 원칙: 적을수록 좋다
"이 폼이 정말 필요한가?"부터 시작하세요
회원가입의 진화
2000년대: 20개 필드 (주민번호까지!)
2010년대: 10개 필드 (최소한으로)
2020년대: 3개 필드 (이메일, 비밀번호, 이름)
현재: 소셜 로그인 (클릭 한 번)
Progressive Profiling의 지혜
첫 방문: 이메일만
첫 구매: 배송 정보
단골 전환: 선호도 조사
VIP 등급: 상세 프로필

Single Column
왜 한 줄이 최고인가?
✅ Single Column
이름     [________________]
이메일   [________________]
비밀번호 [________________]
❌ Multi Column  
이름 [_______]  성 [_______]
이메일 [_______]  전화 [_______]
Single Column의 장점:
예측 가능한 경로: 위에서 아래로만
시선 분산 없음: Z패턴 스캔 불필요
모바일 완벽 대응: 반응형 고민 없음
완료율 높음

논리적 그룹핑
사용자는 관련된 정보를 함께 처리하길 원합니다.
나쁜 예: 뒤죽박죽
이름 → 카드번호 → 주소 → CVC → 이메일 → 만료일
좋은 예: 논리적 그룹
[개인 정보]
이름, 이메일, 전화번호
[배송 정보]  
주소, 우편번호
[결제 정보]
카드번호, 만료일, CVC

Multi-Step Forms: 큰 산을 작은 언덕으로
Single Step 적합
필드 5개 이하
모든 정보가 연관됨
빠른 완료가 목표
Multi Step 필수
필드 5개 초과
논리적 구분 가능
조건부 필드 존재
복잡한 의사결정 필요

Progress Indicator의 심리학
나쁜 진행 표시 = Step 1 of 7  (으... 7단계나?)
좋은 진행 표시 - 거의 다 왔어요! [████████░░] 80%
최고의 진행 표시
✓ 기본 정보 (완료!)
● 배송 정보 (지금 여기)
○ 결제 정보 (마지막!)
왜 최고일까요?
전체가 한눈에 보임
무엇을 완료했는지 명확
남은 것이 무엇인지 예측 가능

진행 효과 활용하기
"사람들은 이미 진행된 작업을 완료하려는 경향이 강하다"
실험 결과
A그룹: 10개 도장 카드 → 완료율 34%
B그룹: 12개 도장 카드 (2개 미리 찍힘) → 완료율 82%
폼에 적용하기
회원가입 시작!
[██░░░░░░░░] 20% 완료 (이메일 입력만으로!)
"이미 시작했으니 끝까지 가자"는 심리를 활용

Radio Button vs Dropdown vs Toggle
Radio Button 사용 시기
옵션 2-5개
모든 옵션을 봐야 할 때
옵션 간 비교가 필요할 때
Dropdown 사용 시기
옵션 6개 이상
공간 절약 필요
기본값이 대부분 적합할 때
Toggle Switch 사용 시기
On/Off 선택
즉시 적용되는 설정
현재 상태가 중요할 때

고급 컨트롤의 활용
Slider: 감각적 선택
가격 범위: ━━━●━━━━━━
               0           5만       10만
정확한 값보다 범위가 중요할 때
시각적 피드백이 도움될 때
최소/최대가 명확할 때
Stepper: 정확한 조절
수량: [-] 2 [+]
작은 범위의 정확한 값
증감이 주 패턴일 때
키보드 입력도 허용

Labels & Placeholders: 명확한 안내
Label의 위치별 장단점
Top-Aligned (추천)
✅ 완료 속도 50% 빠름
✅ 긴 레이블 수용 가능
✅ 번역 대응 용이
❌ 수직 공간 많이 차지
Floating Label
✅ 공간 효율적
✅ 맥락 유지
❌ 구현 복잡
❌ 접근성 이슈 가능

필수 필드 표시 전략
대부분 필수일 때
이름 *
이메일 *
전화번호 (선택)  ← 예외만 표시
주소 *
대부분 선택일 때
이름 *  ← 필수만 표시
닉네임
생년월일
성별

Default의 세 가지 유형
1. Personal Defaults (개인화)
사용자의 과거 행동과 현재 상황을 기반으로 한 예측
예시:
마지막 주문 정보 활용
  → 이전 배송지 주소 자동 입력
  → 최근 결제 수단 기본 선택
위치 기반 추천
  → 사용자가 서울에 있으면 '서울특별시' 자동 선택
  → GPS 기반 가장 가까운 매장 표시

Default의 세 가지 유형
2. Smart Defaults (맥락적)
시간, 상황, 디바이스 등 현재 맥락을 고려한 기본값
예시:
시간대별 다른 기본값
  → 오전 11시 이전: '아침 식사' 카테고리
  → 오후 5시 이전: '점심 식사' 카테고리
  → 저녁 시간: '저녁 식사' 카테고리
디바이스별 최적화
  → 모바일: 간편 결제 우선
  → 데스크톱: 상세 옵션 표시

Default의 세 가지 유형
3. Statistical Defaults (통계적)
다수 사용자의 선택 패턴을 기반으로 한 기본값
예시:
가장 많이 선택되는 옵션
  → 배송 방법: '일반 배송' (82% 선택률)
  → 결제 수단: '신용카드' (76% 선택률)
  → 수량: '1개' (91% 선택률)
A/B 테스트로 검증된 최적값
  → 알림 설정: '중요 알림만' (이탈률 최소)
  → 정렬 순서: '인기순' (전환율 최대)
Dark Pattern 피하기
❌ 마케팅 수신 동의 ☑ (기본 체크)
❌ 자동 갱신 ☑ (기본 체크)
❌ 추가 보험 ☑ (기본 체크)

Validation & Error Handling
Inline Validation의 타이밍
너무 빠른 검증 (좌절감)
이메일: u|  
⚠️ 올바른 이메일이 아닙니다  (아직 입력 중인데!)
적절한 검증 (도움)
이메일: user@|
⚠️ 이메일 도메인을 입력해주세요
에러 메시지의 3요소
무엇이 잘못되었나
❌ "오류가 발생했습니다"
✅ "비밀번호가 너무 짧습니다"
왜 잘못되었나
❌ "유효하지 않음"
✅ "비밀번호는 보안을 위해 8자 이상이어야 합니다"
어떻게 고칠 수 있나
❌ "다시 시도하세요"
✅ "현재 6자입니다. 2자 이상 추가해주세요"

자동 수정 제안
이메일 오타 감지
"user@gmial.com" 입력 시
→ "user@gmail.com을 입력하려고 하셨나요?" [예] [아니오]
전화번호 형식 자동 수정
"01012345678" 입력 시
→ 자동으로 "010-1234-5678"로 표시

폼 디자인의 심리학적 트릭
1. Chunking (청킹)
❌ 16자리 카드번호: 1234567812345678
✅ 4자리씩 구분: 1234 5678 1234 5678
인간의 단기 기억은 7±2개 단위입니다. 긴 정보는 작은 덩어리로 나누세요.
2. Anchoring (앵커링)
기부 금액을 선택하세요:
○ 100,000원 (마음 후원자)
● 50,000원 (사랑 후원자) ← 대부분 선택
○ 30,000원 (응원 후원자)
○ 직접 입력
첫 번째 옵션이 기준점이 됩니다. 전략적으로 배치하세요.
3. Loss Aversion (손실 회피)
"10분 안에 완료하면 10% 할인!"
남은 시간: 08:23
얻는 것보다 잃는 것을 더 싫어하는 심리를 활용합니다.

Break Time

UI Animation: 의미 있는 움직임 설계
애니메이션은 인터페이스의 언어 / 사용자와 시스템 간의 대화를 부드럽게 만드는 중요한 도구
1. 상태 변화의 이해
문제: "방금 무슨 일이 일어났지?"
해결: A상태에서 B상태로의 부드러운 전환
예시: 카드가 펼쳐지며 상세 정보 표시
2. 공간적 관계의 파악
문제: "이 화면이 어디서 나온 거지?"
해결: 화면이 어디서 오고 어디로 가는지 시각화
예시: iOS의 우측 슬라이드 = 깊이 들어가기
3. 시스템 상태의 전달
문제: "지금 뭔가 처리 중인가?"
해결: 진행 상황을 움직임으로 표현
예시: 로딩 스피너, 프로그레스 바

UI Animation 설계의 12가지 이유
1. 사용자 인터페이스 해석 돕기 - 사용자가 "이게 뭐지?"라고 고민하는 순간을 줄인다
햄버거 메뉴가 X로 변하는 모션
탭이 선택되며 콘텐츠가 바뀌는 과정
버튼이 눌리며 다음 화면으로 전환
2. 요소 간 관계 설정 - "이것과 저것이 연결되어 있구나"
리스트 아이템 → 상세 화면 확장
썸네일 → 전체 화면 이미지
장바구니 아이콘으로 날아가는 상품
3. 피드백 제공 - "내 행동이 시스템에 전달되었다"
즉각적인 터치 반응
스와이프에 따른 화면 이동
드래그 앤 드롭의 시각적 피드백

UI Animation 설계의 12가지 이유
4. 방향성과 맥락 제공 - "어디서 왔고 어디로 가는지"
네비게이션의 계층 구조 표현
이전/다음의 명확한 방향성
모달의 출현과 사라짐
5. 주의력 끌기와 유도 - "여기를 봐주세요"
새로운 콘텐츠의 등장
중요한 알림의 애니메이션
CTA 버튼의 미묘한 움직임
6. 에러 예방 - "이렇게 하면 안 돼요"
경계선 도달 시 바운스 효과
잘못된 제스처에 대한 시각적 거부
삭제 전 확인 애니메이션

UI Animation 설계의 12가지 이유
7. 사용자 교육 (온보딩) - "이렇게 사용하세요"
첫 사용 시 제스처 힌트
기능 하이라이트 애니메이션
단계별 튜토리얼 진행
8. 혼란과 기능성 감소 최소화 - "무엇이 무엇인지 명확하게"
요소의 출현과 사라짐 순서
관련 요소들의 그룹 애니메이션
단계적 정보 공개
9. 기대감 설정 - "곧 이런 일이 일어날 거예요"
로딩 진행률 표시
다음 콘텐츠 미리보기
예상 소요 시간 안내

UI Animation 설계의 12가지 이유
10. 즐거운 경험 제공 - "사용하는 게 재미있어요"
마이크로 인터랙션의 즐거움
브랜드 개성 표현
긍정적 감정 강화
11. 인지 부담 감소 - "한 번에 하나씩만 생각하면 돼요"
복잡한 전환을 단계별로
정보의 점진적 공개
시각적 연속성 유지
12. 참여도와 몰입도 향상 - "계속 사용하고 싶어요"
반응성 있는 인터페이스
게임화 요소
성취감을 주는 애니메이션

애니메이션 설계의 핵심 원칙
1. 목적이 있어야 한다 - "왜 이 애니메이션이 필요한가?"
❌ "멋있어 보이니까"
✅ "사용자가 현재 위치를 이해하도록"
✅ "로딩 중임을 알리기 위해"
✅ "성공적 완료를 축하하기 위해"
2. 자연스러워야 한다 - 물리 법칙을 따르는 움직임
Easing: 일정한 속도 ❌, 가속과 감속 ✅
Timing: 너무 빠르거나 느리지 않게
대부분의 UI 애니메이션: 200-400ms
복잡한 전환: 400-600ms
1초 이상은 지루함 유발
3. 성능을 고려해야 한다
Transform(전환)과 Opacity(불투명) 위주 사용
레이아웃 변경 최소화
GPU 가속 활용

애니메이션 타입별 활용 가이드
1. Transform (변형) - 위치, 크기, 회전의 변화
슬라이드 전환
확대/축소 효과
플립 애니메이션
2. Opacity (투명도) - 페이드 인/아웃
요소의 등장과 퇴장
크로스페이드 전환
오버레이 효과
3. Color (색상) - 상태 변화 표현
호버/포커스 상태
성공/실패 피드백
테마 전환
4. Morphing (형태 변환) - 한 형태에서 다른 형태로
햄버거 메뉴 → X 버튼
재생 버튼 → 일시정지 버튼
FAB → 전체 화면

Whitespace: 숨 쉴 공간의 가치
"공백을 기본으로 생각하세요. 모든 것은 공백으로 시작하지만, 요소를 추가하여 공백을 없애기 전까지는 말입니다." - 에릭 D. 케네디
Whitespace(여백)는 콘텐츠가 숨 쉴 수 있는 공간
음악에서 쉼표가 있어야 리듬이 생기듯, 디자인에서도 여백이 있어야 정보가 명확해짐
Whitespace가 없으면 생기는 일
시선이 어디로 가야 할지 모름
정보의 우선순위가 불명확
인지적 피로감 증가
전문성과 신뢰도 하락

Whitespace의 주요 역할
1. 레이아웃 구성과 콘텐츠 구조화 - 정보의 그룹핑과 분리
[헤더]
   ↕ 큰 여백 (섹션 구분)
[메인 콘텐츠]
   ↕ 작은 여백 (단락 구분)
[관련 콘텐츠]
   ↕ 큰 여백 (섹션 구분)
[푸터]
2. 가독성과 스캔 가능성 향상 - 텍스트 주변의 여백
줄 간격 (Line height): 1.5-1.7배
단락 간격: 줄 간격의 1.5-2배
여백이 충분하면 읽기 속도 20% 향상

Whitespace의 주요 역할
3. 시각적 계층 구조 확립 - 중요도에 따른 여백 차등
제목
↕ (큰 여백)
부제목
↕ (중간 여백)
본문
4. 주의력 집중과 강조 - 고립 효과 활용
일반 콘텐츠 | 일반 콘텐츠 | 일반 콘텐츠
        ⬇ 큰 여백
        ⭐ 중요 CTA ⭐
        ⬇ 큰 여백
일반 콘텐츠 | 일반 콘텐츠 | 일반 콘텐츠

Whitespace의 종류와 활용
1. Macro Space (큰 여백) - 요소 그룹 간의 공간
섹션 간 구분
헤더/푸터와 콘텐츠 분리
주요 CTA 주변
2. Micro Space (작은 여백) - 요소 내부의 공간
버튼 내부 패딩
텍스트와 이미지 간격
폼 필드 간격
박스 모델에서의 여백
Margin: 요소 외부 여백
Padding: 요소 내부 여백
Line Spacing: 텍스트 줄 간격
Letter Spacing: 글자 간격

언제 여백을 늘려야 하나?
사용자가 "복잡하다"고 피드백할 때
중요 CTA 전환율이 낮을 때
정보 계층이 불명확할 때
모바일 최적화 시
여백과 비즈니스의 균형
"화면에 더 많이 보여주고 싶어요" (이해관계자) vs "사용자는 한 번에 하나씩 봅니다" (UX 원칙)
해결책:
A/B 테스트로 증명
점진적 공개 전략
중요도에 따른 우선순위

Contrast: 차이가 만드는 명확성
Contrast는 단순히 색상 대비가 아니다
Contrast는 두 요소 간의 시각적 차이를 통해 정보의 위계와 중요도를 전달하는 도구입니다.
Contrast가 없으면?
모든 것이 똑같이 중요해 보임 (= 아무것도 중요하지 않음)
시선의 흐름이 만들어지지 않음
사용자가 다음 행동을 결정하기 어려움

Contrast를 만드는 요소들
1. 색상 (Color) - 가장 즉각적인 주목도
Primary Action: 채도 높은 브랜드 컬러
Secondary Action: 무채색 또는 옅은 색
Disabled: 회색조
2. 크기 (Size) - 중요도의 직접적 표현
H1: 32px - 페이지 제목
H2: 24px - 섹션 제목
Body: 16px - 본문
Caption: 14px - 부가 설명
3. 굵기 (Weight) - 같은 크기에서도 차별화
Bold (700): 제목, 중요 정보
Medium (500): 부제목
Regular (400): 본문
Light (300): 보조 정보

Contrast를 만드는 요소들
4. 위치와 정렬 (Position & Alignment) - 규칙을 깨는 것이 주목을 끈다
중앙 정렬된 CTA
우측 상단의 알림
플로팅 액션 버튼
5. 형태와 스타일 (Shape & Style) - 다른 형태는 다른 기능
둥근 모서리: 친근한 액션
각진 모서리: 공식적 액션
원형: 프로필, 플로팅 버튼

접근성을 고려한 Contrast
WCAG 기준 - 텍스트 대비율
일반 텍스트: 4.5:1 이상
큰 텍스트 (18pt+): 3:1 이상
UI 컴포넌트: 3:1 이상
PM이 체크해야 할 것
✅ 브랜드 컬러가 배경 대비 충분한가?
✅ 에러 메시지가 명확히 보이는가?
✅ 비활성 상태도 구분 가능한가?
✅ 색맹 사용자도 구분 가능한가?

Modals: 맥락 전환의 순간
Modal은 사용자의 주의를 집중시키는 강력한 도구
잘못 사용하면 흐름을 방해하는 장애물이 됩니다.
Modal의 본질
현재 작업을 중단시킴
선택을 강요함
맥락을 전환함

언제 Modal을 사용해야 하나?
✅ 적절한 사용 케이스
1. 중요한 정보 전달
파괴적 액션 확인 (삭제, 취소)
법적 동의 필요
시스템 중요 공지
2. 집중된 작업
짧은 폼 작성
간단한 설정 변경
미디어 미리보기
3. 일시적 상태
로그인/회원가입
공유 옵션
필터 설정

언제 Modal을 사용해야 하나?
❌ 피해야 할 사용
1. 긴 콘텐츠나 복잡한 작업
여러 단계의 폼
긴 약관 텍스트
복잡한 설정
2. 자주 필요한 기능
네비게이션 메뉴
검색
자주 쓰는 필터

Modal 설계의 모범 사례
1. 명확한 진입과 종료 - 사용자가 통제감을 잃지 않도록
진입:
어디서 열렸는지 명확히
부드러운 전환 애니메이션
종료:
X 버튼 (우상단)
배경 클릭으로 닫기
ESC 키로 닫기
2. 포커스 관리 - 접근성과 사용성
Modal 열림: 첫 번째 인터랙티브 요소로 포커스
Tab 키: Modal 내에서만 순환
Modal 닫힘: 원래 위치로 포커스 복귀

Modal 설계의 모범 사례
3. 반응형 디자인
Desktop: 중앙 팝업
Tablet: 전체 너비, 중앙 정렬
Mobile: 전체 화면 또는 하단 시트
4. 콘텐츠 크기 관리
스크롤 최소화
최대 높이 설정 (뷰포트의 90%)
긴 콘텐츠는 페이지로 이동
핵심 정보만 포함

Modal을 선택하기 전에 물어봐야 할 질문들
정말 작업을 중단시켜야 하나?
인라인 편집 가능한가?
새 페이지가 더 적절한가?
사용자가 이 정보를 놓치면 안 되나?
배너나 토스트로 충분한가?
나중에 다시 볼 수 있나?
얼마나 자주 나타나나?
매번 나타나면 피로감
조건부 표시 고려
모바일에서도 적절한가?
작은 화면에서의 경험
터치 인터페이스 고려

실무 적용: 움직임과 공간의 조화
사용자가 "장바구니에 추가" 후 확신 부족
장바구니 페이지로 이동해서 확인 - 쇼핑 플로우 중단
Microinteraction 강화
   버튼 클릭 → 상품이 장바구니로 날아가는 애니메이션
   장바구니 아이콘 뱃지 숫자 증가
   성공 토스트 메시지
Whitespace 활용
   CTA 버튼 주변 충분한 여백
   중요도에 따른 시각적 계층
Contrast 강화
   Primary CTA (장바구니 추가): 강한 색상
   Secondary (계속 쇼핑): 약한 색상
Modal 대신 인라인 피드백
   전체 화면 차단 없이 확인
   쇼핑 플로우 유지

Designing for Error
인간의 특성
실수는 필연적 (Slips & Mistakes)
창의적이고 유연함
맥락을 이해함
불완전하지만 적응력 있음
기계의 특성
정확하고 일관됨
규칙 기반 작동
맥락 이해 부족
완벽하지만 경직됨

Error의 두 가지 유형
1. Slips (실수) - 올바른 목표, 잘못된 실행
이메일을 다른 사람에게 잘못 전송
삭제 버튼을 실수로 클릭
오타 입력
특징: 주의력 부족, 자동화된 행동, 익숙한 패턴의 오작동
2. Mistakes (실패) - 잘못된 목표나 계획
잘못된 메뉴를 선택
틀린 순서로 작업
기능을 오해
특징: 지식 부족, 잘못된 멘탈 모델, 불명확한 피드백

Error 처리의 6단계 라이프사이클
1. Product Development (제품 개발) - 에러를 미리 예측하고 설계
일반적인 실수 패턴 연구
엣지 케이스 고려
프로토타입 테스트
2. Release (출시) - 모니터링 시스템 구축
에러 추적 도구 설정
사용자 피드백 채널
초기 데이터 수집
3. Prevention (예방) - 에러 발생 자체를 차단
제약 조건 설정
명확한 행동 유도
가이드와 힌트
진행 방향 명시

Error 처리의 6단계 라이프사이클
4. Error (에러 발생) - 발견 가능하고 이해 가능하게
즉각적인 피드백
명확한 에러 표시
상황 정보 제공
5. Recovery (복구) - 빠르고 쉬운 복구 경로
Undo 기능
자동 저장/복구
명확한 해결 방법
대안 제시
6. Reporting/Redesign (개선) - 지속적인 개선 사이클
에러 패턴 분석
사용자 피드백 수집
디자인 개선
A/B 테스트

Error Prevention: 예방이 최선의 치료
1. 제약을 통한 예방 - Poka-Yoke (실수 방지) 원칙
물리적 제약:
날짜 선택: 과거 날짜 비활성화
숫자 입력: 범위 제한
파일 업로드: 형식 제한
논리적 제약:
- 순차적 작업 강제
- 조건부 활성화
- 상호 배타적 옵션
2. 경고 신호 설계 - 위험 수준별 시각화
낮음: 정보성 메시지 (파란색)
중간: 주의 필요 (노란색)
높음: 위험 경고 (빨간색)

Error Prevention: 예방이 최선의 치료
3. 기본값과 제안 - 스마트한 기본 설정
안전한 옵션을 기본으로
일반적인 선택 제안
자동 완성 기능
4. 점진적 공개 - 복잡성 관리
필요한 때 필요한 정보만
고급 옵션은 숨김
단계별 가이드

Error Recovery: 실패에서 배우기
복구 설계의 원칙
1. 최소한의 영향
입력 데이터 보존
컨텍스트 유지
진행 상황 보존
2. 명확한 경로 제시
현재 상황: "무엇이 잘못되었나"
해결 방법: "어떻게 고치나"
대안 제시: "다른 방법은"
3. 심리적 안정감
비난하지 않는 톤
해결 가능함을 강조
도움 제공 의사 표현

복구 메커니즘
Undo/Redo
즉각적인 실행 취소
다단계 되돌리기
히스토리 관리
자동 저장과 복구
주기적 자동 저장
충돌 시 복구
버전 관리
우회 경로
대체 방법 안내
수동 처리 옵션
고객 지원 연결

Error Messages: 인간적인 커뮤니케이션
좋은 에러 메시지의 구조
1. 무엇이 일어났는가 (What)
❌ "Error 404"
✅ "페이지를 찾을 수 없습니다"
2. 왜 일어났는가 (Why)
❌ "Invalid input"
✅ "이메일 주소에 @가 포함되어야 합니다"
3. 어떻게 해결하나 (How)
❌ "Try again"
✅ "이메일 주소를 확인하고 다시 입력해주세요"

톤과 보이스 가이드라인
명확성 (Clarity)
기술 용어 배제
구체적 설명
간결한 문장
공감 (Empathy)
사용자 입장 고려
스트레스 인정
격려하는 어조
긍정성 (Positivity)
해결 중심 메시지
가능성 강조
다음 단계 제시

상황별 메시지 예시
네트워크 오류
❌ "Network Error: Connection Failed"
✅ "인터넷 연결을 확인해주세요. 연결이 불안정한 것 같습니다. 잠시 후 다시 시도해주세요."
입력 검증 실패
❌ "Validation Error"
✅ "비밀번호는 8자 이상이어야 합니다.현재 6자를 입력하셨네요.2자 더 추가해주세요."
권한 오류
❌ "Access Denied"
✅ "이 페이지를 보시려면 로그인이 필요합니다.로그인 후 계속하실 수 있어요."[로그인하기] [돌아가기]

예시: 파일 업로드 실패
현재: "Upload failed" → 재시도 → 반복 실패
1. 예방
   지원 형식 명시
   드래그 전 검증
   파일 크기 사전 체크
2. 에러 발생
   "파일이 너무 큽니다 (최대 10MB)"
   현재 파일: 15MB
   진행률 표시로 어디서 멈췄는지
3. 복구
   [파일 압축하기] 도구 제공
   [다른 파일 선택]
   [도움말 보기]

좋은 UI = 좋은 대화

그룹 과제(3인 1조)
평소에 자주 사용하지만 UI가 맘에 안들었던 제품을 하나 선택하고 사람들과 공유합니다.
해당 제품의 주요 페이지의 UI 구조를 학습한 내용들에 맞춰 분석해 정리합니다.
각 파트별로 목적에 맞게 설계되지 않은 부분을 찾아 학습한 내용에 맞춰 개선 제안을 정리합니다.
그 중 제품의 핵심 가치 구현에 맞게 우선순위를 정하고 UI 개선 계획을 수립합니다.

질의응답 & 토론

수고하셨습니다
