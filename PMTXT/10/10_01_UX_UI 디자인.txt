UX/UI 디자인(1)
좋은 디자인의 본질

사전 질문(15분)
좋은 디자인은 무엇일까요? 이런 디자인을 구현해 내기 위해서 어떤 것들을 고려해야 할까요?

사용자에게 이 제품을 사용하는 방법을 이해시키기 위해서는 어떤 점들을 고려해 설계해야 할까요?

사전 질문 토론
1. 좋은 디자인의 정의와 구현을 위한 고려사항
좋은 디자인은 사용자의 문제를 정확히 이해하고, 이를 기능과 형태로 직관적으로 풀어낸 것이다.
사용자가 고민 없이 이해할 수 있도록 직관성과 심미성을 갖추며, 기능성도 중요하다.
이를 위해 사용자 관점의 리서치와 시장 분석, 반복 테스트가 필요하다.
기술적 제약과 브랜드 아이덴티티까지 고려하며 일관된 사용자 경험을 유지하는 것이 중요하다.
2. 사용자가 제품 사용법을 이해하도록 설계할 때 고려할 점
직관적 인터페이스와 명확한 시각적 계층 구조를 설계해야 한다.
표준 UI 패턴과 피드백을 제공하고, 초기 온보딩 경험을 고려한다.
필요시 도움말과 가이드, 실수 복구 기능을 포함해 사용성을 높인다.
사용자가 고민 없이 사용법을 파악할 수 있도록 설계하는 것이 핵심이다.

Case: 레퍼런스 분석을 통한 좋은 디자인 학습
셀프 케어 앱 개발 중 기능 개선을 위해 다양한 경쟁 제품들을 분석해 봄
잘나가는 제품들은 유사하게도 비슷한 UI/UX 설계를 갖추고 있었음
온보딩을 통해 초기 핵심 기능을 사용하게 하는 과정
요소들을 배치해놓은 구조, 메뉴를 통해 접근할 수 있는 기능
핵심 기능을 사용하는 방법, 정보를 관리하는 방법
그와 비교했을 때 우리의 제품은 익숙하지 않은 사용법을 가지고 있었음
팀 내부에서 논의
우리만의 독창적인 경험을 제공하는 것이 중요하다
많은 고객들이 익숙하게 사용하는 방식이 효과적이다
두 기능을 A/B 테스트를 통해 검증 - 결과는?

익숙한 것이 최선일 때가 있다
다른 제품과 유사한 경험을 설계한 것이 활성화율이 더 높음
우리만의 독창적인 가치를 제공한다고 할 지라도, 고객은 익숙한 것을 사용하는 것을 선호
어떤 문제를 해결하기 위한 과정은 독창성보다는 편의성이 훨씬 중요한 요소

인간이 문제를 해결하기 위해 어떻게 행동하는가?
이런 행동을 통해 문제를 해결하도록 유도하기 위해 어떤 것들을 고려해야 하는가?
디자인을 이해하는 것은 인간의 행동을 이해하는 것

문 손잡이의 비밀
여러분은 오늘 몇 개의 문을 열었나요?
그리고 그 중 몇 개의 문에서 당기기/밀기를 헷갈렸나요?
"문을 열 때 밀어야 할지 당겨야 할지 헷갈린다면, 그것은 당신의 잘못이 아니라 디자인의 실패입니다."
디자인은 소통이다
디자인은 사용자와 제품 간의 대화입니다
제품은 "나를 이렇게 사용하세요"라고 무언의 메시지를 전달합니다
사용자는 그 메시지를 직관적으로 이해할 수 있어야 합니다

디자인은 어떻게 문제를 해결하는가?
디자인의 본질: 인간과 목표 사이의 다리
디자인은 단순히 예쁘게 꾸미는 것이 아닙니다
인간이 목표를 달성하도록 돕는 문제 해결 도구입니다.
문제 해결의 3가지 장벽
인지적 장벽: "뭘 해야 하지?"
물리적 장벽: "어떻게 해야 하지?"
감정적 장벽: "이게 맞나?"
좋은 디자인은 이 세 가지 장벽을 모두 낮춥니다.

인간은 어떻게 사물과 상호작용하는가?
1단계: 발견(Discovery) - "이게 뭐지?"
처음 보는 커피머신 앞에 선 당신
눈이 자동으로 버튼을 찾습니다
손잡이나 레버를 확인합니다
무언가를 넣는 곳과 나오는 곳을 파악합니다
→ 이 단계에서 실패하면? "이거 어떻게 켜는 거야?"
사용자가 제품을 처음 만났을 때 거치는 첫 단계입니다.
무엇을 할 수 있는지 파악합니다
어떤 부분이 조작 가능한지 찾습니다
제품의 목적과 기능을 이해하려 합니다

인간은 어떻게 사물과 상호작용하는가?
2단계: 이해(Understanding) - "어떻게 작동하지?"
이제 각 요소의 역할을 추측합니다.
"이 빨간 버튼은 아마 전원이겠지"
"이 구멍에 캡슐을 넣는 것 같은데"
"여기서 물이 나오겠구나"
→ 이 단계에서 실패하면? "버튼은 찾았는데 뭐가 뭔지 모르겠어"
제품의 작동 원리를 파악하는 단계입니다.
각 요소가 무엇을 하는지 추측합니다
행동과 결과의 관계를 이해합니다
멘탈 모델을 형성합니다

인간은 어떻게 사물과 상호작용하는가?
3단계: 실행(Execution) - "이렇게 하면 되겠지?"
마침내 행동에 옮깁니다.
캡슐을 넣고
버튼을 누르고
커피가 나오기를 기다립니다
→ 이 단계에서 실패하면? "분명히 다 했는데 왜 안 되지?"
목적을 달성하기 위해 행동하는 단계입니다.
의도를 행동으로 전환합니다
제품과 물리적으로 상호작용합니다
피드백을 통해 결과를 확인합니다

행동의 7단계 이론: 사용자가 포기하는 정확한 지점 찾기
"왜 어떤 사용자는 발견은 했는데 실행하지 못할까?"
"왜 어떤 사용자는 실행은 했는데 다시 돌아오지 않을까?"
실제로 인간의 행동은 더 복잡하게 일어난다
실제 사례: 첫 출근 날의 커피머신
신입사원의 목표: "커피 한 잔 마시고 싶다"
실제로는...
"어? 이 머신 어떻게 작동하지?"
"버튼이 6개나 있네... 뭐가 뭔지..."
"이거 눌러도 되나?"
"아무 일도 안 일어나는데?"
"아... 먼저 컵을 놓았어야 했구나"
이런 혼란이 왜 일어날까요? - 7단계 행동 이론

행동의 7단계 이론: 사용자가 포기하는 정확한 지점 찾기

행동의 7단계 분석
1단계: 목표 형성 (Forming the Goal)
가장 추상적인 수준의 욕구입니다. 아직 구체적인 방법은 정해지지 않았습니다.
특징: 여러 방법으로 달성 가능
예: "방을 밝게 하고 싶다"
디자인 시사점: 사용자의 진짜 목표가 무엇인지 이해해야 함
2단계: 의도 형성 (Forming the Intention)
목표를 달성하기 위한 의도를 형성합니다. 여러 대안 중 하나를 선택합니다.
특징: 목표를 구체적 행동 의도로 변환
예: "전등 스위치를 켜야겠다" (커튼을 열거나 촛불을 켤 수도 있었지만)
디자인 시사점: 사용자가 우리 제품을 해결책으로 떠올리게 만들어야 함

행동의 7단계 분석
3단계: 행동 순서 명세화 (Specifying an Action Sequence)
의도를 실행 가능한 행동 순서로 구체화합니다.
특징: 정신적 모델에 기반한 행동 계획
예: "벽에 있는 스위치를 위로 올려야지"
디자인 시사점: 행동 순서가 명확하고 논리적이어야 함
4단계: 행동 실행 (Executing the Action)
계획한 행동을 물리적으로 실행합니다.
특징: 실제 조작이 일어나는 유일한 단계
예: 손을 뻗어 스위치를 위로 올림
디자인 시사점: 물리적/디지털 조작이 쉽고 정확해야 함

행동의 7단계 분석
5단계: 외부 세계 상태 지각 (Perceiving the State)
시스템의 새로운 상태를 감각으로 인지합니다.
특징: 감각 정보의 수집 (시각, 청각, 촉각 등)
예: 불이 켜진 것을 봄, 스위치의 위치 변화를 봄
디자인 시사점: 상태 변화가 명확히 지각 가능해야 함
6단계: 상태 해석 (Interpreting the Perception)
지각한 정보에 의미를 부여합니다.
특징: 감각 정보를 의미 있는 정보로 변환
예: "아, 전등이 켜졌구나"
디자인 시사점: 피드백이 이해하기 쉬워야 함

7단계: 결과 평가 (Evaluating the Outcome)
7. 비교 (Compare)
결과를 원래 목표와 비교하여 성공 여부를 판단합니다.
특징: 목표 달성 여부의 최종 평가
예: "방이 충분히 밝아졌다" 또는 "아직도 어둡네"
디자인 시사점: 목표 달성이 명확히 확인 가능해야 함

실무 적용: 사진 공유 앱의 7단계
목표: "가족들과 오늘 찍은 사진을 공유하고 싶다"
의도: "가족 그룹 채팅방에 사진을 올려야겠다"
명세: "갤러리 열기 → 사진 선택 → 공유 → 카톡 선택"
실행: 실제로 터치하여 수행
지각: "전송됨" 표시와 1 표시를 봄
해석: "사진이 전송되었고 읽지 않은 상태구나"
평가: "성공적으로 공유했다"
각 단계에서 디자인이 실패하면:
3단계 실패: 공유 버튼을 못 찾음
5단계 실패: 전송 중인지 완료인지 구분 안 됨
7단계 실패: 정말 모든 가족이 볼 수 있는지 불확실

실행과 평가의 심연 (Gulfs of Execution and Evaluation)
실행의 다리 (1→2→3→4)
목표에서 시작해 물리적 행동으로 변환되는 과정
각 단계는 점점 더 구체적이고 물리적으로 변함
심연이 클수록: "어떻게 해야 할지 모르겠다"
실행의 심연 (Gulf of Execution)
사용자의 심리적 목표와 시스템이 요구하는 물리적 조작 사이의 차이
사용자는 자신이 원하는 것(목표)을 시스템이 이해할 수 있는 형태(물리적 조작)로 변환해야
이 변환 과정이 어려울수록 심연이 깊어짐
실행의 심연 사례
사용자가 스마트폰의 사진 앱에서 사진을 삭제하려고 할 때
'삭제' 버튼이 어디에 있는지 찾기 어렵거나
버튼의 모양이 명확하지 않아서 원하는 행동으로 전환하기 힘든 경우.

실행과 평가의 심연 (Gulfs of Execution and Evaluation)
평가의 다리 (5→6→7)
물리적 변화를 지각하고 목표와 비교하는 과정
각 단계는 점점 더 추상적이고 심리적으로 변함
심연이 클수록: "무슨 일이 일어났는지 모르겠다"
평가의 심연 (Gulf of Evaluation)
시스템의 물리적 상태와 사용자의 심리적 해석 사이의 차이
시스템은 자신의 상태를 물리적으로 표현하지만
사용자는 이를 자신의 목표와 기대에 비추어 해석해야
이 해석이 어려울수록 심연이 깊어짐
평가의 심연 사례
프린터의 상태 표시등이 빨간색으로 깜빡일 때
사용자가 그 의미(예: 종이가 걸렸는지, 잉크가 부족한지)를
정확히 이해하지 못하고 해결 방법을 찾기 어려운 경우.

각 단계에서 발생하는 전형적인 문제들
1-2단계 문제: 의도 형성 실패
증상: "이 앱으로 뭘 할 수 있는지 모르겠어요"
원인: 제품의 가치와 기능이 불명확
해결: 명확한 가치 제안, 기능 발견성 향상
3단계 문제: 행동 계획 실패
증상: "하고 싶은 건 아는데 어떻게 하는지 모르겠어요"
원인: 복잡한 인터페이스, 불명확한 경로
해결: 단순화, 명확한 정보 구조

각 단계에서 발생하는 전형적인 문제들
4단계 문제: 실행 실패
증상: "버튼이 너무 작아요", "입력이 어려워요"
원인: 물리적 제약, 조작성 문제
해결: 적절한 크기와 간격, 편리한 입력 방식
5단계 문제: 지각 실패
증상: "클릭했는데 아무 일도 안 일어나요"
원인: 피드백 부재 또는 지연
해결: 즉각적이고 명확한 피드백

각 단계에서 발생하는 전형적인 문제들
6단계 문제: 해석 실패
증상: "뭔가 변했는데 무슨 의미인지 모르겠어요"
원인: 애매한 메시지, 기술적 용어
해결: 명확하고 사용자 친화적인 언어
7단계 문제: 평가 실패
증상: "이게 내가 원한 결과인지 확실하지 않아요"
원인: 불명확한 완료 상태, 확인 부족
해결: 명확한 성공 지표, 확인 메시지

7단계 이론으로 문제 진단하기
사례: 온라인 쇼핑몰 장바구니 이탈
관찰: 70%가 장바구니에서 이탈
7단계 분석:
1-2단계: 구매 의도는 있음 (장바구니까지 왔으니)
3단계: "결제하기" 버튼을 못 찾음? → 버튼 위치 개선
4단계: 결제 과정이 너무 복잡? → 단계 축소
5-6단계: 진행 상황을 모름? → 단계 표시 추가
7단계: 주문 완료 확신 부족? → 확인 페이지 강화
실제 문제: 5단계에서 예상치 못한 배송비 표시
해결: 더 일찍 배송비 정보 제공

멘탈 모델: 사용자의 머릿속 지도
멘탈 모델이란? 사용자가 제품이 어떻게 작동할 것이라고 믿는 내적 모델입니다.
세 가지 모델의 차이:
구현 모델: 실제로 시스템이 작동하는 방식
멘탈 모델: 사용자가 생각하는 작동 방식
표현 모델: 디자이너가 사용자에게 전달하는 방식
멘탈 모델의 형성
과거 경험에서 학습
유사한 제품에서 전이
문화적 관습의 영향
시행착오를 통한 학습

멘탈 모델: 사용자의 머릿속 지도
1. 구현 모델 (Implementation Model)
"실제로 어떻게 작동하는가"
예: 이메일 시스템
실제: SMTP 프로토콜, 서버 간 패킷 전송, DNS 조회...
너무 복잡해서 사용자가 알 필요 없음

멘탈 모델: 사용자의 머릿속 지도
2. 멘탈 모델 (Mental Model)
"사용자가 생각하는 작동 방식"
예: 이메일에 대한 사용자의 생각
"편지를 디지털 우체통에 넣으면 상대방 우체통에 도착한다"
단순하지만 사용하기에 충분한 모델

멘탈 모델: 사용자의 머릿속 지도
3. 표현 모델 (Represented Model)
"디자이너가 사용자에게 보여주는 방식"
예: Gmail 인터페이스
받은편지함, 보낸편지함, 휴지통
실제 우편 시스템의 메타포 사용
좋은 디자인의 목표: 표현 모델을 통해 사용자의 멘탈 모델과 구현 모델의 간극을 좁히는 것

멘탈 모델의 형성과 진화
형성 단계
전이: 기존 경험에서 가져옴 - "휴지통 = 버린 것을 담는 곳"
학습: 사용하면서 수정 - "아, 휴지통에서도 복구할 수 있구나"
고착: 반복 사용으로 굳어짐 - 이후 변경이 매우 어려워짐
멘탈 모델 충돌의 예
사용자: "파일을 삭제했는데 용량이 안 늘어요"
실제: 휴지통에 있는 파일도 용량 차지
해결: 휴지통 비우기 기능 강조
교훈: 사용자의 멘탈 모델을 바꾸려 하지 말고, 그것에 맞춰 디자인하라

일상 속 실험: 리모컨의 비밀
집에 있는 TV 리모컨을 한번 보세요. 
버튼이 몇 개나 있나요? 
보통 40-50개입니다. 
그런데 흥미로운 사실:
대부분의 사람은 5-6개 버튼만 사용합니다
나머지 버튼의 기능을 모릅니다
그런데도 불편하지 않습니다
머릿속 지식 (Knowledge in the Head) & 세상 속 지식 (Knowledge in the World)

두 가지 지식의 본질
머릿속 지식 (Knowledge in the Head): 우리가 학습하고 기억하는 정보입니다.
일상 예시:
집 현관 비밀번호
자주 가는 카페의 WiFi 비밀번호
엄마 전화번호 (요즘은 아닐수도...)
즐겨 쓰는 단축키
세상 속 지식 (Knowledge in the World): 환경에 존재하는 정보입니다.
일상 예시:
문에 붙은 "당기세요/미세요" 표시
키보드의 글자 배치
내비게이션의 음성 안내
앱의 메뉴와 버튼 라벨

정밀성과 지식의 관계
정밀한 행동이 필요할 때 - 머릿속 지식 필수:
비밀번호 입력 (정확한 문자)
전화번호 다이얼 (정확한 숫자)
코드 작성 (정확한 문법)
대략적 행동이면 충분할 때 - 세상 속 지식 활용:
메뉴에서 선택 (보고 고르기)
설정 조정 (슬라이더 움직이기)
경로 탐색 (표지판 따라가기)

에러와 실수: 인간의 한계 이해하기
사용자는 항상 실수합니다. 이는 어리석어서가 아니라 인간이기 때문입니다.
1. 실수(Slip) - 올바른 목표, 잘못된 실행
상황: 이메일을 상사에게 보내려다 동료에게 보냄
원인:
자동화된 행동: 익숙한 패턴을 무의식적으로 수행
주의력 분산: 멀티태스킹 중 발생
유사성: 비슷한 이름, 비슷한 위치
디자인 해결책:
자동완성 시 사진과 직책 표시
"정말 보내시겠습니까?" 확인 (중요 메일)
실행 취소 기능 (5초 이내)

기능별 차별화 전략
핵심 기능: 머릿속 지식화 유도
반복 사용으로 자연스럽게 암기
일관된 위치와 단축키
예: Ctrl+S (저장), Cmd+Z (실행취소)
보조 기능: 세상 속 지식 제공
메뉴에서 찾을 수 있게
검색 가능하게
예: 고급 필터, 특수 설정
위험한 기능: 의도적 마찰 추가
여러 단계 확인
명시적 경고
예: 계정 삭제, 전체 초기화

에러와 실수: 인간의 한계 이해하기
2. 실패(Mistake) - 잘못된 목표 설정
상황: 할인 쿠폰을 적용하려다 주문을 취소함
원인:
잘못된 멘탈 모델: 시스템 작동 방식 오해
불명확한 피드백: 현재 상태 파악 실패
복잡한 절차: 목표 달성 경로가 불분명
디자인 해결책:
명확한 단계 표시 (1/3 → 2/3 → 3/3)
각 단계의 목적 설명
언제든 이전 단계로 돌아갈 수 있게

에러를 다루는 4단계 전략
1. 예방 (Prevention)
"에러가 발생할 수 없게 만들어라"
예시: 날짜 입력
나쁜 방법: 자유 텍스트 입력 → "2024/13/45" 가능
좋은 방법: 달력 위젯 → 잘못된 날짜 선택 불가
2. 감지 (Detection)
"에러가 발생하면 즉시 알려라"
예시: 비밀번호 설정
실시간 피드백:
✓ 8자 이상
✗ 대문자 포함 필요
✗ 특수문자 포함 필요

에러를 다루는 4단계 전략
3. 진단 (Diagnosis)
"무엇이 잘못되었는지 명확히 설명하라"
나쁜 메시지: "오류가 발생했습니다"
좋은 메시지: "이메일 주소에 @가 포함되어야 합니다"
4. 복구 (Recovery)
"쉽게 되돌릴 수 있게 하라"
복구 방법:
Undo 기능
자동 저장된 초안
이전 버전 히스토리

Break Time

강제 기능이란?
특정 행동을 하지 않으면 다음 단계로 진행할 수 없게 만드는 물리적 또는 논리적 제약
실수를 방지하는 가장 확실한 방법

인터록 (Interlock)
락인 (Lock-in)
락아웃 (Lock-out)



강제 기능이란? - 1. 인터록 (Interlock)
정의: 올바른 순서로만 작동하도록 강제하는 메커니즘
물리적 예시:
전자레인지: 문이 열려 있으면 작동 불가
자동차: 기어가 P에 있지 않으면 시동키를 뺄 수 없음
세탁기: 작동 중에는 문이 잠김
디지털 예시 - 설치 마법사:
1단계 완료 → 2단계 버튼 활성화
2단계 완료 → 3단계 버튼 활성화
이전 단계 미완료 시 진행 불가
PM 적용:
결제 프로세스: 필수 정보 입력 전 결제 버튼 비활성화
계정 생성: 이메일 인증 전 서비스 이용 제한
파일 업로드: 업로드 완료 전 다음 단계 차단

강제 기능이란? - 1. 인터록 (Interlock)
정의: 올바른 순서로만 작동하도록 강제하는 메커니즘
물리적 예시:
전자레인지: 문이 열려 있으면 작동 불가
자동차: 기어가 P에 있지 않으면 시동키를 뺄 수 없음
세탁기: 작동 중에는 문이 잠김
디지털 예시 - 설치 마법사:
1단계 완료 → 2단계 버튼 활성화
2단계 완료 → 3단계 버튼 활성화
이전 단계 미완료 시 진행 불가
PM 적용:
결제 프로세스: 필수 정보 입력 전 결제 버튼 비활성화
계정 생성: 이메일 인증 전 서비스 이용 제한
파일 업로드: 업로드 완료 전 다음 단계 차단

강제 기능이란? - 2. 락인 (Lock-in)
정의: 작업을 시작하면 완료할 때까지 멈출 수 없게 하는 메커니즘
물리적 예시:
고속도로 진입로: 한번 진입하면 다음 출구까지 나갈 수 없음
회전문: 들어가면 완전히 통과해야 함
디지털 예시 - 중요 업데이트:
"업데이트가 진행 중입니다...
완료될 때까지 기기를 끄지 마세요"→ 중단 시 시스템 손상 방지
PM 적용 시 주의점:
사용자를 가두는 것은 매우 조심스럽게 사용
반드시 진행 상황 표시
예상 소요 시간 안내
정말 필요한 경우에만 사용

강제 기능이란? - 3. 락아웃 (Lock-out)

정의: 위험한 상황에 들어가지 못하게 차단하는 메커니즘
물리적 예시:
약병 안전캡: 아이들이 열지 못하게 설계
산업 장비: 안전 장치 없이는 작동 불가
금고: 여러 번 틀리면 일정 시간 잠김
디지털 예시 - 보안 락아웃:
5회 로그인 실패 → 계정 일시 잠금
의심스러운 활동 감지 → 추가 인증 요구
관리자 권한 필요 작업 → 일반 사용자 접근 차단
PM 적용:
중요 데이터 삭제: 여러 단계 확인
대량 작업: 권한 확인 필수
비정상 패턴: 자동 차단 후 검증

강제 기능 설계 원칙
1. 최소한의 불편함
안전을 위한 최소한의 단계만 추가
과도한 강제는 사용자 이탈 유발
2. 명확한 이유 설명
나쁜 예: "진행할 수 없습니다"
좋은 예: "안전을 위해 이메일 인증이 필요합니다"

강제 기능 설계 원칙
3. 우회 경로 고려
정당한 예외 상황 대비
관리자나 고급 사용자를 위한 옵션
단, 우회 자체도 안전하게 설계
4. 상황에 맞는 강도
낮은 위험: 소프트한 경고
중간 위험: 확인 필요
높은 위험: 강제 기능 적용

강제 기능의 균형
과도한 사용의 문제점:
사용자 좌절감 증가
작업 효율성 저하
신뢰 관계 훼손
부족한 사용의 문제점:
실수로 인한 손실
보안 취약점
사용자 불안감
황금률: 실수의 비용 > 강제 기능의 불편함일 때만 사용

실제 적용 사례 분석

성공 사례: Gmail의 실수 방지
상황: "첨부파일"이라는 단어가 있는데 파일 없이 전송
강제 기능: "파일을 첨부하지 않으셨습니다. 그래도 보내시겠습니까?"
효과: 실수 방지하면서도 의도적 전송 가능
실패 사례: 과도한 비밀번호 규칙
상황: 특수문자, 대소문자, 숫자 모두 필수
문제: 너무 복잡해서 사용자가 기억 못함
결과: 오히려 보안 약화 (종이에 적어둠)

좋은 디자인의 근본 원리
1. 가시성(Visibility) - "보이는 것이 사용할 수 있는 것이다"
원리: 중요한 기능은 눈에 잘 띄어야 하고, 작동 방식이 명확해야 합니다.
나쁜 예:
버튼처럼 생기지 않은 버튼
숨겨진 메뉴나 제스처 기반 기능
피드백이 없는 터치 인터페이스
좋은 예:
엘리베이터의 층수 버튼 - 누를 수 있음이 명확하고, 현재 층이 표시됨
구글 검색창 - 텍스트를 입력할 수 있음이 즉시 이해됨

좋은 디자인의 근본 원리
문제 상황: 최신 인덕션 레인지
매끈한 검은 유리판
전원을 켜기 전엔 아무것도 보이지 않음
손님들: "이거 어떻게 켜요?"
해결책: 중요한 것은 보여야 한다
터치 영역에 희미한 표시
전원 버튼은 항상 보이게
현재 상태를 명확히 표시

좋은 디자인의 근본 원리
2. 피드백(Feedback) - "모든 행동에는 즉각적이고 명확한 반응이 있어야 한다"
원리: 사용자의 행동에 대해 시스템이 어떻게 반응하는지 즉시 알려줘야 합니다.
피드백의 종류:
시각적: 버튼 색상 변화, 로딩 애니메이션
청각적: 클릭음, 알림음
촉각적: 진동, 버튼의 물리적 움직임
나쁜 예:
클릭해도 아무 반응이 없는 버튼 (작동하는지 안 하는지 모름)
진행 상황을 보여주지 않는 긴 프로세스
좋은 예:
좋아요 버튼 - 즉시 색이 바뀌고 애니메이션이 작동
파일 업로드 진행률 표시

좋은 디자인의 근본 원리
인간의 기대: 물리적 세계에서 우리는 즉각적인 피드백에 익숙합니다
문을 밀면 → 움직이거나 저항감을 느낌
스위치를 누르면 → 불이 켜지거나 소리가 남
디지털 제품의 도전:
터치스크린은 물리적 피드백이 없음
네트워크 지연으로 즉각적 반응이 어려움
피드백의 계층:
즉각적 피드백 (0.1초 이내): 버튼 색상 변화, 눌림 효과
진행 피드백 (1초 이상): 로딩 애니메이션, 진행률 표시
완료 피드백: 성공/실패 메시지, 다음 단계 안내

좋은 디자인의 근본 원리
3. 제약(Constraints) - "실수를 원천적으로 방지하는 디자인"
원리: 잘못된 사용을 물리적, 논리적으로 불가능하게 만듭니다.
좋은 예:
신용카드 리더기 - 카드를 잘못된 방향으로 넣을 수 없음
폼 유효성 검사 - 잘못된 이메일 형식은 제출 불가

좋은 디자인의 근본 원리
물리적 제약
USB-C의 양방향 설계 (이전 USB의 50% 실패율 해결)
신용카드 칩의 방향 (한쪽만 칩이 있음)
의미적 제약
🔴 빨간색 = 정지, 위험, 삭제
🟢 초록색 = 진행, 안전, 확인
💾 플로피 디스크 = 저장 (젊은 세대도 이해)
논리적 제약
비밀번호 없이 계정 삭제 불가
결제 정보 없이 구매 불가
이메일 형식이 맞지 않으면 제출 불가
문화적 제약
읽기 방향: 좌→우 (서양), 우→좌 (아랍)
체크표시: ✓ (서양), ○ (일본)

좋은 디자인의 근본 원리
4. 매핑(Mapping) - "조작부와 결과 사이의 자연스러운 관계"
원리: 컨트롤과 그 효과 사이에 직관적인 관계가 있어야 합니다.
나쁜 예:
4개의 버너와 무작위로 배치된 4개의 조절 손잡이
좌우가 반대로 작동하는 수도꼭지
좋은 예:
자동차 창문 스위치 - 배치가 실제 창문 위치와 일치
캐러셀 UI - 좌우 스와이프가 콘텐츠 이동 방향과 일치

좋은 디자인의 근본 원리
자연스러운 매핑:
스티어링 휠을 오른쪽으로 돌리면 차가 오른쪽으로
볼륨 다이얼을 시계방향으로 돌리면 소리가 커짐
위쪽 스위치는 위쪽 조명을 제어
디지털 제품에서의 매핑:
좌우 스와이프 → 좌우 콘텐츠 이동
핀치 줌 → 확대/축소
아래로 당기기 → 새로고침

좋은 디자인의 근본 원리
5. 일관성(Consistency) - "비슷한 것은 비슷하게 작동해야 한다"
원리: 사용자의 기존 지식과 경험을 활용할 수 있도록 일관된 패턴을 유지합니다.
좋은 예:
모든 앱에서 X 버튼은 닫기를 의미
저장 아이콘은 플로피 디스크 모양 (아무도 플로피를 안 써도)
휴지통 아이콘은 삭제를 의미
일관성이 깨질 때의 혼란:
안드로이드에서 아이폰으로 (뒤로가기 버튼은 어디에?)
윈도우에서 맥으로 (Command vs Control)

좋은 디자인의 근본 원리
1. 내부 일관성 (한 제품 내)
Gmail 내에서:
모든 삭제는 휴지통 아이콘
모든 작성은 + 버튼
모든 설정은 톱니바퀴
2. 외부 일관성 (업계 표준)
모든 앱에서:
X = 닫기
🔍 = 검색  
⚙️ = 설정
💾 = 저장
3. 메타포 일관성 (현실 세계)
디지털이 현실을 따르는 것:
쓰레기통 = 삭제
폴더 = 분류
돋보기 = 검색

좋은 디자인의 근본 원리
6. 행동유도성(Affordance) - "사물의 특성이 사용 방법을 암시한다"
원리: 제품의 물리적 특성이나 시각적 단서가 어떻게 사용해야 하는지 직접적으로 알려줍니다.
실제 행동유도성 vs 지각된 행동유도성:
실제: 버튼은 누를 수 있다 (물리적 특성)
지각된: 그림자와 입체감으로 버튼처럼 보인다 (시각적 단서)
물리적 세계의 행동유도성:
문 손잡이 → 잡고 돌린다
버튼 → 누른다
슬롯 → 무언가를 넣는다

좋은 디자인의 근본 원리
디지털 제품에서의 행동유도성:
밑줄 친 텍스트 = 클릭 가능한 링크
입체적인 버튼 = 누를 수 있음
텍스트 필드 = 입력 가능
행동유도성의 진화:
스큐어모피즘 (2007-2012): 실제 사물을 그대로 모방
플랫 디자인 (2013-2014): 너무 단순해서 버튼인지 구분 안 됨
머티리얼 디자인 (2014-현재): 적절한 그림자와 깊이로 균형

원리의 통합: 엘리베이터 버튼의 비밀
평범한 엘리베이터 버튼이 6가지 원리를 모두 사용하는 방법:
1. 가시성: 눈높이에 위치, 조명으로 강조
2. 피드백:
누르면 불이 켜짐 (시각)
"딩" 소리 (청각)
때로는 진동 (촉각)
3. 제약:
이미 선택된 층은 다시 누를 수 없음
존재하지 않는 층 번호는 없음

원리의 통합: 엘리베이터 버튼의 비밀
4. 매핑:
높은 층 = 위쪽 버튼
낮은 층 = 아래쪽 버튼
5. 일관성:
전 세계 어디서나 비슷한 방식
숫자 체계 동일
6. 행동유도성:
튀어나온 버튼 = 누를 수 있음
오목한 모양 = 손가락이 들어갈 곳

PM이 빠지기 쉬운 디자인 함정
1. 지식의 저주
"내가 아는 것을 사용자도 당연히 알 거라는 착각"
PM은 제품을 너무 잘 압니다. 매일 보고, 만들고, 테스트합니다. 그래서 초보자의 눈을 잃어버립니다.
증상:
"이 정도는 직관적이지 않나?"
"사용자가 이걸 못 찾을 리 없어"
"매뉴얼 보면 되잖아"
해독제:
신입 직원 테스트: 첫 날 온보딩하면서 제품 사용하게 하기
할머니 테스트: 기술에 익숙하지 않은 사람에게 설명하기
5초 테스트: 5초만 보고 무엇을 하는 제품인지 알 수 있는가?

PM이 빠지기 쉬운 디자인 함정
2. 기능 크리프 (Feature Creep)
"더 많은 기능 = 더 좋은 제품"이라는 환상
진행 과정:
v1.0: 핵심 기능 3개 (사용자 만족도 90%)
v2.0: 기능 10개 추가 (만족도 85%)
v3.0: 기능 30개 (만족도 70%)
v4.0: "이 앱 너무 복잡해" (이탈)
해결책: 기능 다이어트
사용 데이터 분석: 실제로 쓰이는 기능은?
80/20 법칙: 20%의 기능이 80%의 가치
감추기, 제거하기, 통합하기

PM이 빠지기 쉬운 디자인 함정
3. 미적 우선주의
"예쁘면 다 용서된다?"
아름다움 vs 사용성의 균형:
극단적 미니멀리즘:
모든 것이 하얗고 깨끗함
버튼인지 텍스트인지 구분 안 됨
"이거 어떻게 써요?"
과도한 장식:
화려한 애니메이션
복잡한 그래픽
로딩이 너무 오래 걸려요"
황금률: 형태는 기능을 따른다 (Form Follows Function)
먼저 잘 작동하게 만들고
그 다음 아름답게 만들어라
아름다움이 사용성을 해치면 안 됨

PM이 빠지기 쉬운 디자인 함정
4. 혁신의 덫
"남들과 달라야 한다"는 강박
혁신을 위한 혁신의 위험:
잘 작동하는 패턴을 버림
사용자의 학습 비용 무시
"창의적"이지만 "직관적"이지 않음
현명한 혁신:
문제가 있는 곳에만 혁신
나머지는 친숙한 패턴 유지
점진적 변화로 사용자 적응 도움

복잡성 vs 복잡함: 기능을 추가하되 단순하게 유지하는 법

복잡성 ≠ 복잡함
복잡성 (Complexity)
정의: 많은 부분이나 기능으로 구성된 상태
특징: 현실 세계의 필연적 속성
평가: 중립적 (좋지도 나쁘지도 않음)
복잡함 (Complicated)
정의: 이해하고 사용하기 어려운 상태
특징: 나쁜 디자인의 결과
평가: 부정적 (항상 피해야 함)

복잡하고 복잡한 것들 (실패 사례)

구형 리모컨
50개의 버튼이 모두 노출
계층 구조 없음
라벨만으로 구분
결과: 5개만 사용
기업용 소프트웨어
모든 기능이 메뉴에 나열
컨텍스트 무시
우선순위 없음
결과: 교육 없이 사용 불가

복잡하고 복잡한 것들 (실패 사례)

구형 리모컨
50개의 버튼이 모두 노출
계층 구조 없음
라벨만으로 구분
결과: 5개만 사용
기업용 소프트웨어
모든 기능이 메뉴에 나열
컨텍스트 무시
우선순위 없음
결과: 교육 없이 사용 불가

PM이 알아야 할 디자인 사고
1. 사용자는 매뉴얼을 읽지 않는다
제품은 스스로 설명할 수 있어야 합니다
복잡한 온보딩보다 직관적인 디자인이 중요합니다
필요한 순간에 필요한 정보만 제공해야 합니다
2. 사용자는 탐험가가 아니다
대부분의 사용자는 새로운 방식을 시도하기보다 익숙한 패턴을 선호합니다
혁신적인 인터페이스보다 예측 가능한 경험이 중요합니다
창의성은 문제 해결에, 인터페이스는 익숙함에
3. 복잡성은 피할 수 없다
기능이 많아질수록 복잡성은 증가합니다
중요한 것은 복잡성을 어떻게 관리하고 숨기는가입니다
점진적 공개와 맥락적 기능 제공이 핵심입니다

사용자 중심 디자인 프로세스
1. 관찰과 이해 - 사용자를 그들의 환경에서 관찰하라
실제 사용 맥락에서의 행동 관찰
말하는 것과 행동하는 것의 차이 인식
우회 행동과 임시방편 해결책 주목
핵심 질문들:
사용자가 실제로 달성하려는 목표는 무엇인가?
현재 어떤 불편을 감수하고 있는가?
어떤 실수를 반복적으로 하는가?
2. 문제 정의 - 진짜 문제 vs 표면적 증상
"로딩이 느려요" → 실제 문제: 진행 상황을 모르는 불안감
"기능이 부족해요" → 실제 문제: 핵심 작업 흐름의 단절
"디자인이 구려요" → 실제 문제: 정보 계층 구조의 부재

사용자 중심 디자인 프로세스
3. 개념 모델 설계 - 사용자가 이해할 수 있는 모델 만들기
복잡한 시스템을 단순한 모델로 추상화
일관된 메타포 사용
점진적 복잡성 공개
좋은 개념 모델의 예:
데스크톱 메타포: 파일, 폴더, 휴지통
쇼핑 카트: 온라인 쇼핑의 장바구니
탭: 브라우저의 다중 페이지 관리
4. 프로토타이핑과 테스트 - 빠른 실패, 빠른 학습
낮은 충실도 프로토타입으로 핵심 개념 검증
실제 사용자와 함께 테스트
가정이 아닌 관찰에 기반한 개선

그룹 연구(3인 1조)
좋은 디자인을 가졌다고 생각하는 프로덕트를 하나 선정합니다.
해당 프로덕트의 주요 기능을 하나 선택해 해당 기능을 사용하는 절차에 대해 행동의 7단계에 기반하여 분석을 합니다.
이 행동을 유도하기 위한 디자인 요소를 검토하고 이를 6가지 좋은 디자인의 원리에 맞게 잘 설계되었는지 검토합니다. 
이 과정에서 어떤 인사이트를 발견했는지 논의하고 이를 정리해 봅니다.

질의응답 & 토론

수고하셨습니다
