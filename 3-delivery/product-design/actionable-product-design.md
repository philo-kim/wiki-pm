# 실행 가능한 제품 설계

## 개요

PRD 조율이 완료된 후, 실제 개발이 시작되기 위해서는 추가적인 설계 문서와 정보가 필요합니다. PRD가 '무엇을(What)' 만들지를 정의했다면, 실행 가능한 제품 설계는 '어떻게(How)' 구현할지를 구체화하는 단계입니다.

> 💡 **핵심 원칙**: 최종 목적은 '고객'이 이 기능을 통해 '가치'를 느끼게 되는 것입니다. 정책을 정하고 문서를 만드는 것이 목표가 아니라, 고객이 사용하는데 어려움이 없어야 합니다.

## PRD의 목적과 한계

### PRD의 역할
- 주로 '무엇을(What)' 만들지를 정의하는 문서
- 비즈니스 가치와 핵심 기능에 초점
- 모든 이해관계자 간의 조율을 통한 방향 설정

### PRD의 한계
- 모든 상황과 맥락을 담기에는 한계가 있음
- 문서는 읽는 사람의 배경과 경험에 따라 다르게 해석됨
- 구체적인 구현 세부사항까지 포함하기 어려움

## 실행 가능한 제품 설계의 핵심 요소

### 1. 정보 구조화(IA)와 사용자 흐름 정의
- 제품 전체 구조에서 기능의 위치와 관계 정의
- 사용자 목표 달성을 위한 단계별 여정 설계

### 2. 화면 상태와 전환 조건 구체화
- 각 화면의 다양한 상태와 변화 조건 정의
- 입력 요소의 유효성과 피드백 방식 설계

### 3. 비즈니스 정책과 규칙 명확화
- 데이터 처리와 표시에 대한 구체적 규칙 정의
- 시스템 동작의 논리적 기준과 제약 조건 설정

### 4. 예외 상황과 오류 처리 방안 정의
- 일반적 흐름을 벗어나는 상황 식별
- 사용자 관점에서의 오류 처리와 복구 경로 설계

## 정보 구조화(Information Architecture, IA)

### IA란?
사용자가 디지털 제품 내에서 정보를 쉽게 찾고 이해할 수 있도록 정보의 구조와 흐름을 설계하는 작업입니다.

**❌ 단순한 메뉴 구성이 아님**
- IA는 내비게이션 구성에 그치지 않음
- 사용자의 목적과 맥락에 맞는 정보 구조 전반을 설계
- 메뉴, 카테고리, 라벨, 화면 간 흐름 등 정보 소비 방식 전체에 영향

### 핵심 구성 요소

#### 1. 조직화 구조 (Organization)
- 기능/화면/콘텐츠의 분류 및 계층화
- 논리적이고 직관적인 그룹핑

#### 2. 레이블링 (Labeling)
- 사용자가 의미를 직관적으로 이해할 수 있는 명칭 사용
- 내부 용어가 아닌 사용자 언어로 표현

#### 3. 탐색 시스템 (Navigation)
- 사용자가 정보를 찾아 이동하는 구조
- 일관성 있고 예측 가능한 내비게이션

#### 4. 검색 시스템 (Search)
- 원하는 정보에 빠르게 접근할 수 있는 검색 구조
- 검색 결과의 관련성과 정확성

> 💡 **좋은 IA는 사용자가 "이 다음에 뭘 하면 되지?"라고 묻지 않게 만듭니다.**

### IA가 중요한 이유

정보가 잘 구조화되지 않으면:
- "디자인은 했는데 사용자들이 기능을 못 찾아요"
- "홈 화면에 다 있어요, 그런데 아무도 안 써요"
- "검색만 의존하고, 구조가 없어요"
- "메뉴 명칭이 우리끼리만 아는 용어예요"

### 실무 사례

#### ❌ 잘못된 IA 사례
**문제 상황:**
- 사용자가 송금 기능을 찾기 어려움
- 홈 화면엔 배너와 추천 콘텐츠만 있음
- '송금' 메뉴는 '더보기 > 금융도구 > 기타'에 위치
- 화면은 예쁘지만 사용 흐름과 연결되지 않음

**결과:**
- 기능 활용률 저조
- 사용자는 앱을 "불편하다"고 인식
- CS 및 이탈률 증가

#### ✅ 개선된 IA 사례
**개선 포인트:**
- 홈 화면 상단에 자주 쓰는 기능 → '빠른 송금' 바로가기 배치
- '송금' 메뉴는 '내 계좌 > 자산 관리 > 송금'의 명확한 위치로 이동
- 사용자 행동 데이터 기반으로 메뉴 순서 정렬
- 메뉴 명칭을 내부 용어가 아닌 사용자 언어로 수정 (예: '이체도우미' → '송금')

**결과:**
- 기능 접근성 개선 → 사용률 상승
- 사용자 만족도 향상, 문의 감소
- PM과 디자이너 간 구조 정렬로 반복 수정 줄어듦

### PM과 디자이너의 IA 협업

디자이너는 단순히 화면을 그리는 사람이 아닙니다. IA를 기반으로 사용자 흐름과 정보 구조를 시각적으로 구체화하는 파트너입니다.

**PM이 IA 기반으로 디자이너와 협업할 때 해야 할 질문:**
1. 이 기능은 사용자에게 어디에서, 왜, 어떻게 도달해야 할까?
2. 이 화면은 어떤 상위 기능 구조에 속하는가?
3. 사용자가 이 위치에 도달했을 때, 어떤 선택지와 흐름이 제시되어야 할까?
4. 기능은 존재하는가가 아니라, 발견 가능한가(findable)?
5. 사용자가 다음 단계를 예측할 수 있을 정도로 구조화되어 있는가?

## 사용자 흐름(User Flow) 설계

### User Flow란?
사용자가 특정 목표를 달성하기 위해 제품 내에서 거치는 행동 경로와 상태 전이 과정을 시각화한 구조도입니다.

단순한 "홈 → 로그인 → 완료" 순서가 아니라 사용자의 의도, 선택, 조건, 심리적 맥락까지 고려된 전체 경험의 흐름 설계입니다.

### 화면 흐름 vs 사용자 흐름

| 구분 | 화면 흐름(Screen Flow) | 사용자 흐름(User Flow) |
|------|------------------------|------------------------|
| 기준 | 화면 전환 구조 | 사용자 목표 달성 과정 |
| 중심 | 기능 또는 UI 구성 | 사용자 행동 및 의사결정 |
| 구성 | A → B → C 화면 | 선택지, 분기점, 조건 포함 |
| 목적 | 화면 연결 흐름 파악 | 실제 사용 시나리오 검토 및 설계 |

### User Flow가 담아야 할 정보

#### 1. 사용자 목표
- 사용자가 이 기능을 통해 달성하려는 최종 목적
- 예: "친구에게 빠르게 돈을 보낸다"

#### 2. 핵심 행동 경로 (Happy Path)
- 가장 이상적인 시나리오
- 예: 홈 → 수취인 선택 → 금액 입력 → 인증 → 완료

#### 3. 의사결정 포인트 (Decision Point)
- 사용자 선택에 따라 흐름이 분기되는 지점
- 예: 연락처에서 선택 vs 계좌번호 직접 입력

#### 4. 조건/예외 흐름
- 정상 흐름 외에 예외 상황 대응 경로
- 예: 잔액 부족, 인증 실패, 서버 오류 등

#### 5. 시스템 상태 및 피드백
- 입력 결과에 따라 화면이나 시스템이 제공하는 반응
- 예: 오류 메시지, 로딩 상태, 성공 알림

### 실무 활용 방안

#### 협업 대상별 활용
- **디자이너**: 사용자 중심의 흐름을 기반으로 UI 설계
- **개발자**: 로직 분기와 상태 관리 기준 명확히 이해
- **QA**: Happy Path + 예외 흐름 포함한 검증 가능
- **CS**: 어디에서 문제가 발생할 수 있는지 사전 인지

### User Flow 작성 팁

1. **사용자 목표로 시작하라**: '기능 흐름'이 아닌 '사용자 여정' 중심으로 구성
2. **실제 분기와 조건을 명시하라**: 예외 없이 단선적인 흐름은 현실과 맞지 않음
3. **시스템 상태를 생략하지 말라**: 로딩, 실패, 제한 조건 등 모두 설계의 일부
4. **비주얼로 표현하되 말로도 설명하라**: 도해 + 짧은 설명문 병행이 가장 효과적
5. **협업 툴을 활용하라**: Miro, Figma, Lucidchart 등으로 실시간 피드백 가능

## 프로토타입 이후 정의해야 할 정보 구조

### 작성 전 확인 사항

1. **이 기능은 사용자에게 어떤 목표를 달성하게 하는가?**
   - 기능 중심이 아닌 목적 중심 사고 유도

2. **사용자는 어떤 흐름으로 이 기능에 도달하는가?**
   - 메뉴 구조와 접근성을 결정

3. **기능은 어떤 상태를 가지며, 상태 전환 조건은 무엇인가?**
   - 화면 구성 기준이 됨

4. **예외 상황은 무엇이며, 어떻게 처리되어야 하는가?**
   - 사용자 혼란 방지, UX 안정성 확보

### 필수 정의 항목

1. UI 상태 정의 (UI States / 컴포넌트 상태 설명)
2. 입력 및 행위 조건 정의 (Validation Rules)
3. 업무 및 비즈니스 정책 정의 (Business Rules)
4. 조건 조합 결과 정의 (결정 테이블)
5. 예외 흐름 정의 (Edge Case Flow)
6. 오류 및 시스템 피드백 설계 (Error UX)

## 1. UI 상태 정의 (UI States)

### 개념
하나의 화면 혹은 컴포넌트가 여러 가지 상황에 따라 시각적으로 또는 기능적으로 달라지는 모습을 정의합니다.

### 왜 필요한가?
- 디자이너가 모든 상태를 다 그리지 않으면 개발자가 임의로 판단
- 기획자는 happy path만 작성하고 예외 상태를 빠뜨리는 경우가 많음
- QA는 명확한 상태 정의가 없으면 무엇이 정상인지 모르고 테스트
- 상태가 정의되지 않으면 컴포넌트 단위 재사용이나 디자인 시스템화가 불가능

### 실무에서 구분해야 할 상태 종류

| 상태 유형 | 설명 | 예시 |
|----------|------|------|
| 입력 상태 (Input States) | 사용자가 입력 중일 때, 유효/무효 여부에 따라 바뀌는 UI 상태 | 포커스, 입력 중, 검증 완료 |
| 시스템 상태 (System Response) | 처리 중, 완료, 실패 등 시스템이 주도하는 상태 | 로딩, 처리 중, 완료 |
| 피드백 상태 (Feedback States) | 성공, 실패, 주의 등 사용자에게 전달되는 메시지 중심 상태 | 성공 알림, 경고, 오류 |
| 디폴트 상태 (Default / Empty) | 초기 진입 시 아무 데이터도 없을 때의 상태 | 빈 화면, 초기값 |
| 에러 상태 (Error States) | 시스템 오류, 입력 오류 등 예외 발생 시 | 검증 실패, 서버 오류 |

### 실무 예시: 금액 입력 컴포넌트의 상태 정의

| 상태 | 시각적 표현 | 동작 | 전환 조건 |
|------|------------|------|----------|
| 초기 | 회색 테두리, placeholder 표시 | 입력 가능 | 화면 진입 시 |
| 포커스 | 파란색 테두리, 커서 활성화 | 입력 가능 | 필드 클릭 |
| 입력 중 | 파란색 테두리, 실시간 포맷팅 | 천 단위 콤마 자동 삽입 | 값 입력 시 |
| 유효 | 초록색 체크 아이콘 | 다음 단계 활성화 | 유효성 검증 통과 |
| 오류 | 빨간색 테두리, 오류 메시지 | 입력 수정 필요 | 유효성 검증 실패 |

### 실무 작성 팁
- **초기/입력중/완료는 무조건 명시**: 상태 구분이 없으면 디폴트만 개발됨
- **모든 입력 필드는 유효/무효 상태를 가짐**: Validation 정의와 연결됨
- **오류는 항상 시각적 피드백 + 메시지 + 동작 차단 포함**: 세 가지 요소 빠짐없이 기획
- **상태가 전환되는 조건을 함께 정의**: 어떤 액션/조건에서 상태가 바뀌는지 꼭 명시
- **UI마다 상태 정의는 표 형태로 통일**: 문서 전체 일관성 확보 및 이해 용이

## 2. 입력 조건 및 유효성 규칙 (Validation Rules)

### 개념
사용자가 입력 필드나 인터랙션 요소를 사용할 때 허용되는 값의 기준과 제약을 정의합니다. 단순한 숫자/문자 입력 여부를 넘어서, 기능이 작동하기 위한 최소한의 전제 조건을 설계합니다.

### 입력 조건의 주요 구성 요소

| 구성 요소 | 설명 | 예시 |
|-----------|------|------|
| 허용 타입 | 입력 가능한 데이터의 형식 | 숫자만 입력 가능, 이메일 형식 |
| 범위 | 최소/최대값 또는 길이 제한 | 1,000원 이상, 6자리 숫자 |
| 형식 포맷 | 입력값의 시각적/문자적 규칙 | 천 단위 콤마, 하이픈 자동 삽입 |
| 실시간 검증 | 입력 중 조건 위반 여부를 즉시 확인 | 형식 오류 시 빨간 테두리 |
| 조건 충족 후 동작 | 조건 만족 시 다음 단계 또는 버튼 활성화 | 입력 완료 시 '다음' 버튼 활성화 |

### Validation의 유형

| 유형 | 설명 | 예시 |
|------|------|------|
| 형식 검증 (Format) | 특정 패턴에 맞는지 확인 | 이메일 주소, 전화번호, 숫자 |
| 범위 검증 (Range) | 값이 정해진 범위 안에 있는지 확인 | 1,000원 이상, 6자리 이하 |
| 필수 항목 (Required) | 반드시 입력되어야 하는지 여부 | 약관 동의 체크박스 |
| 논리 검증 (Logical) | 비즈니스 로직에 따른 조건 | 잔액보다 큰 금액 불가 |
| 중복/정합성 검증 | 다른 정보와 일치 또는 중복 여부 확인 | 비밀번호 재입력 일치 확인 |

### 실무 예시: 송금 기능의 금액 입력 필드

| 항목 | 조건 | 오류 메시지 | 처리 방식 |
|------|------|------------|----------|
| 입력 타입 | 숫자만 허용 | - | 문자 입력 차단 |
| 최소 금액 | 1,000원 이상 | "최소 송금 금액은 1,000원입니다" | 버튼 비활성화 |
| 최대 금액 | 1회 300만원 | "1회 송금 한도를 초과했습니다" | 버튼 비활성화 |
| 잔액 확인 | 잔액 이하 | "잔액이 부족합니다" | 잔액 충전 유도 |
| 포맷 | 천 단위 콤마 | - | 자동 포맷팅 |

### 입력 조건 설계 시 유의사항
- **조건은 명확하고 수치화되어야 함**: "적당히", "충분히"는 금지. 수치로 표현
- **사용자의 행동 결과를 예측할 수 있도록 설계**: 잘못된 입력 시 어떤 일이 일어나는지 명확히 안내
- **형식 제한 + 메시지 + 동작 차단은 항상 함께**: 제한만 있으면 당황, 메시지만 있으면 혼란

## 3. 업무 및 비즈니스 정책 정의 (Business Rules)

### 개념
제품이 일관되게 동작하도록 하기 위해, 회사나 서비스 차원에서 정한 규칙이나 제약 조건입니다. 입력 조건이 "사용자의 행위 제한"이라면, 정책은 "서비스가 기능을 허용할지 결정하는 기준"입니다.

### 정책과 조건의 차이

| 항목 | 조건 (Validation) | 정책 (Business Rule) |
|------|-------------------|----------------------|
| 목적 | 사용자의 입력을 제한 | 기능 동작의 기준을 제시 |
| 적용 시점 | UI 상 입력 단계 | 기능 수행 전 또는 중간 |
| 작성 기준 | 수치, 포맷 중심 | 서비스 기준, 법적 요건 등 |
| 예시 | 1,000원 이상만 입력 가능 | VIP 등급만 1,000만원 송금 허용 |

### 정책의 주요 구성 요소

1. **정책 ID**: 정책을 식별할 수 있는 코드 (예: TRANS-001)
2. **정책명**: 해당 정책의 목적 또는 영역을 명확히 나타낸 이름
3. **목적**: 왜 이 정책이 필요한지, 해결하고자 하는 문제
4. **적용 범위**: 어떤 기능, 화면, 사용자군에 적용되는지
5. **조건 및 내용**: 정책이 발동되는 조건, 실행 시 동작 방식
6. **예외 규정**: 특수 상황에서 정책이 변경되는 경우
7. **변경 이력**: 정책 변경 또는 폐기 시 기록용

### 정책 정의 예시

```
[정책 ID]: TRANS-001
[정책명]: 송금 한도 정책
[목적]: 등급별 송금 한도를 설정하여 사기 방지 및 금융 리스크 완화
[적용 대상]: 모든 송금 기능 사용자

[정책 내용]
- 일반 사용자: 1회 최대 300만원, 일일 500만원
- 우수 사용자: 1회 최대 500만원, 일일 1,000만원
- VIP 사용자: 1회 최대 1,000만원, 일일 2,000만원

[예외 규정]
- 인증 수단 강화 시 한도 최대 2배까지 임시 상향 가능
- 계정 이상 징후 감지 시 임시 한도 제한 적용

[변경 이력]
- 2025-01-01: VIP 등급 한도 상향 (기존 700만원 → 1,000만원)
```

### 정책 정의 시 유의점
- **"서비스가 왜 이렇게 동작하는가"를 설명**: 단순 제약 나열이 아닌, 이유와 목적 포함
- **구체적인 수치와 조건을 명시**: "적절한 수준" → "1,000만원 이하"로 표현
- **QA 테스트가 가능하도록 명세 형태로 작성**: 정책마다 테스트 시나리오가 도출되어야 함
- **예외 상황까지 반드시 정의**: 없는 경우 실무에서 임의 처리 발생 가능성 높음
- **정책은 버전 관리가 필수**: 정책은 바뀔 수 있음 → 추적 가능하게 관리 필요

## 4. 조건 조합 결과 정의 (결정 테이블)

### 개념
여러 조건이 동시에 작용할 때 어떤 결과가 도출되어야 하는지를 체계적으로 정리한 표입니다. 복잡한 정책이나 로직이 있을 때, 조건의 조합별로 행동을 명확히 정의합니다.

### 왜 필요한가?
- 조건이 2개 이상 복합적으로 적용될 때 로직이 꼬이거나 빠지기 쉬움
- 구두 설명이나 문장만으로는 모든 케이스를 빠짐없이 설명하기 어려움
- QA의 테스트 시나리오, 개발자의 조건 분기 처리, 디자이너의 예외 설계까지 공통 기준점 제공
- 조건 충돌/중복 여부를 논리적으로 검토 가능

### 예시: 송금 수수료 결정 테이블

| 규칙 ID | 사용자 등급 | 송금 금액 | 시간대 | 수수료 | 비고 |
|--------|------------|-----------|--------|---------|------|
| R1 | 일반 | 10만원 미만 | 평일 | 1,000원 | 기본 수수료 |
| R2 | 일반 | 10만원 이상 | 평일 | 2,000원 | 고액 수수료 |
| R3 | 우수 | 모든 금액 | 평일 | 500원 | 우대 수수료 |
| R4 | VIP | 모든 금액 | 모든 시간 | 무료 | VIP 혜택 |
| R5 | 모든 등급 | 모든 금액 | 주말/공휴일 | +500원 | 휴일 할증 |

### 구성 요소
- **조건 항목**: 분기 판단의 기준이 되는 변수 (등급, 시간대 등)
- **결과 항목**: 조건의 조합에 따라 출력되거나 실행되는 결과 (수수료, 권한 등)
- **규칙 ID**: 각 행의 고유 식별자. 정책 변경이나 테스트 추적에 사용
- **와일드카드**: '전체' 또는 '무관' 등을 써서 조건 생략 가능

### 언제 사용하는가?
- 조건이 많고 경우의 수가 폭증할 때 (3개 조건만 있어도 8가지 조합 발생)
- 정책 변경이 잦아 검토가 필요한 경우
- QA에서 테스트 누락을 방지하고 싶을 때
- 개발자와 구현 로직 논의 시 기준이 필요할 때

### 실무 작성 팁
- **조건 항목은 최대한 독립 변수로 구성**: 서로 영향을 주는 항목은 우선 분리
- **규칙 ID는 QA/개발 테스트에서 반드시 사용**: R1, R2… 형태로 명시하면 추적 용이
- **공통 결과는 그룹핑 또는 기본값 지정**: 중복된 결과를 묶거나 별도 규칙으로 처리
- **변경/추가가 쉬운 포맷 사용**: Google Sheet 등으로 관리하면 정책 변화 대응 유연

## 5. 예외 흐름 정의 (Edge Case Flow)

### 개념
사용자가 일반적인 흐름(Happy Path)을 따르지 못하거나, 시스템이 비정상적인 상황에 직면했을 때 작동하는 대체 흐름입니다. 엣지 케이스는 확률은 낮지만 발생 시 치명적일 수 있는 비정형 상황을 의미합니다.

### 왜 중요한가?
- 실제 사용자의 대부분은 예외 상황을 겪음
- 예외 대응이 없거나 허술하면, 사용자가 포기하거나 시스템 오류로 이어짐
- CS/QA 이슈의 대부분이 예외 상황에서 발생
- 제품의 신뢰성과 완성도를 결정짓는 핵심 요소

### 예외 흐름 설계의 기본 구성

| 구성 요소 | 설명 |
|----------|------|
| 예외 상황 ID | 고유 식별자 (Ex: E001) |
| 발생 조건 | 어떤 조건에서 발생하는지 |
| 영향 | 사용자가 어떤 문제를 겪는지 |
| 처리 방안 | 시스템/사용자에게 어떤 조치를 취할 것인지 |
| 사용자 메시지 | 어떤 메시지/안내를 보여줄 것인지 |
| 복구 가능 여부 | 재시도 가능, 수동 조치 필요 여부 |

### 예시: 송금 기능의 예외 흐름 테이블

| ID | 예외 상황 | 발생 조건 | 처리 방안 | 사용자 메시지 | 복구 가능 |
|----|-----------|----------|----------|---------------|-----------|
| E001 | 잔액 부족 | 송금액 > 계좌 잔액 | 송금 차단 | "잔액이 부족합니다" | 충전 후 재시도 |
| E002 | 인증 실패 | 비밀번호 3회 오류 | 계정 일시 잠금 | "보안을 위해 잠금되었습니다" | CS 문의 필요 |
| E003 | 네트워크 오류 | 서버 응답 없음 | 자동 재시도 (3회) | "연결 중입니다..." | 자동 복구 |
| E004 | 중복 요청 | 동일 요청 5초 내 | 두 번째 요청 무시 | "처리 중입니다" | 대기 필요 |

### 사용자 관점에서 예외 설계하기
- **명확한 원인 안내**: "잘못되었습니다" → ❌ / "인증번호가 틀렸습니다" → ✅
- **복구 유도**: 취소/다시 시도 버튼, 이전 단계로 복귀 등
- **시스템 책임 강조**: 사용자 잘못 아님을 명확히 (서버 오류 시)
- **지속적 상태 유지**: 중단된 상태에서도 정보가 보존되도록 설계

## 6. 오류 및 시스템 피드백 설계 (Error UX)

### 개념
사용자가 예상하지 못한 결과를 마주했을 때, 시스템이 전달하는 메시지와 반응 방식입니다. 오류 메시지 설계는 단순 안내 문구 작성이 아니라, 사용자가 다음에 무엇을 할 수 있는지를 명확히 알려주는 행동 안내 설계입니다.

### 왜 중요한가?
- 대부분의 사용자는 정상 흐름이 아닌 상태에서 제품을 기억함
- "에러가 났다"보다 "에러가 났을 때 어떻게 대응했는가"가 더 중요한 경험
- 애매한 피드백은 혼란, 포기, CS 유입으로 이어짐
- 명확한 메시지와 복구 안내는 사용자 불안 해소와 재시도 유도에 핵심

### 실무 설계 시 고려할 요소

1. **상황 인식**: 어떤 조건에서 발생했는지 정확히 표현
2. **원인 명확화**: 사용자 책임 vs 시스템 오류 구분
3. **행동 제안**: "다시 시도", "고객센터 문의", "뒤로 가기" 등 다음 행동을 안내
4. **시각적 구분**: 오류/성공 상태를 시각적으로 명확히 구분 (색상, 아이콘 등)
5. **정서적 톤**: 비난/경고가 아닌, 안내/지원의 톤으로 설계

### 오류 메시지 유형별 예시

| 유형 | 설계 원칙 | 메시지 예시 |
|------|----------|------------|
| 입력 오류 | 원인 명확히 제시 + 입력 수정 유도 | "이메일 형식이 올바르지 않습니다." |
| 인증 실패 | 사용자 실수 명확화 + 재입력 유도 | "인증번호가 일치하지 않습니다. 다시 입력해주세요." |
| 시스템 오류 | 복구 불가한 상황에서의 안내 | "잠시 후 다시 시도해주세요. (오류코드: 503)" |
| 연결 실패 | 사용자 조치가 가능한 경우 | "네트워크 상태가 불안정합니다. 연결을 확인해주세요." |
| 제한 초과 | 정책 기반 안내 + 해결책 제시 | "오늘의 송금 한도를 초과했습니다." |
| 성공 피드백 | 완료 후 신뢰 강화 + 다음 행동 유도 | "송금이 완료되었습니다. 내역에서 확인하실 수 있어요." |

### 실무 예시: 메시지 매트릭스

| 상황 | 타입 | 메시지 | 액션 | 시각 |
|------|------|--------|------|------|
| 필수 입력 누락 | 경고 | "필수 항목을 입력해주세요" | 해당 필드로 포커스 | 노란색 아이콘 |
| 형식 오류 | 오류 | "올바른 이메일 형식이 아닙니다" | 재입력 유도 | 빨간색 테두리 |
| 처리 성공 | 성공 | "저장되었습니다" | 다음 단계 진행 | 초록색 체크 |
| 서버 오류 | 시스템 | "일시적 오류입니다 (E500)" | 재시도 버튼 표시 | 빨간색 알림 |

### 실무 설계 팁
- **사용자 책임 여부 구분**: "잘못된 입력"과 "시스템 오류"는 명확히 구분하여 표현
- **에러코드 제공**: 반복 이슈 시 CS 대응을 위한 코드 삽입 (Ex: E503)
- **시각적 패턴 통일**: 오류: 빨강, 성공: 초록, 경고: 노랑 등 일관성 유지
- **재시도 가능성 포함**: 가능할 경우 '다시 시도' 버튼 기본 제공
- **모바일 대응**: 화면 공간 제한 고려 → 요약 메시지 + 상세 팝업 분리

## 린 환경에서의 기획 정보 전달 원칙

### 1. 점진적 상세화 전략
- 처음부터 모든 것을 완벽하게 정의하지 않음
- 개발 단계에 맞춰 필요한 정보를 적시에 제공
- 초기에는 핵심 흐름과 주요 화면에 집중
- 반복적인 피드백과 개선을 통한 진화

### 2. 우선순위 기반 접근
- 모든 상태와 예외를 동일하게 취급하지 않음
- 비즈니스 가치와 사용자 영향도에 따른 우선순위 설정
- P0(필수), P1(중요), P2(선택) 등으로 구분
- 핵심(P0)에 집중하고 나머지는 점진적으로 해결

### 3. 문서와 소통의 균형
- 문서화와 대화 중 더 효과적인 방식 선택
- 복잡한 로직과 규칙은 문서화, 맥락과 의도는 대화로 전달
- 시각적 도구를 활용한 효율적 커뮤니케이션
- 장황한 설명보다 명확한 예시와 시연 활용

### 4. 협업 툴의 전략적 활용
- Figma, Miro 등 실시간 협업 도구로 효율성 증대
- 모든 이해관계자가 접근 가능한 중앙화된 정보 관리
- 변경사항의 실시간 공유와 피드백
- 문서 관리 오버헤드 감소

### 5. 지속적인 참여 모델
- 문서 전달 후 "담 넘기기"가 아닌 지속적 협업
- 개발 과정 전반에 걸친 PM의 참여와 피드백
- 짧은 피드백 루프를 통한 빠른 조정
- 정기적인 리뷰와 학습 사이클 운영

## 핵심 정리

> 💡 **제품 설계 문서는 필요한 내용을 '기획'하는 것이 목적이 아닌, MVP의 목적을 달성하는 데 필요한 구체적인 사항들을 협의하는 것에 있다**

실행 가능한 제품 설계는 PRD에서 정의한 비전을 실제 사용자가 경험할 수 있는 제품으로 변환하는 과정입니다. 이를 위해서는:

1. **사용자 중심의 구조 설계**: IA와 User Flow를 통한 직관적인 경험 설계
2. **상세한 상태 정의**: 모든 가능한 상황에서의 UI 동작 명세
3. **명확한 규칙과 정책**: 일관된 제품 동작을 위한 비즈니스 규칙 정의
4. **예외 상황 대비**: 엣지 케이스와 오류 상황에 대한 체계적 대응
5. **지속적인 협업**: 문서 전달이 아닌 팀 전체의 지속적 참여

성공적인 제품 설계는 완벽한 문서가 아니라, 팀 전체가 같은 목표를 향해 효과적으로 협업할 수 있는 공통의 이해를 만드는 것입니다.